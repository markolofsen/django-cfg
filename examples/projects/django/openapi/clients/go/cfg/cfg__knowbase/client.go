// Code generated by django-cfg/django_client - DO NOT EDIT.
// Generated at: 2025-10-27T19:13:24.696136

package cfg__knowbase

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	// Import shared package for error types
	"cfg/shared"
)

// Client provides access to cfg__knowbase operations.
type Client struct {
	BaseURL    string
	HTTPClient *http.Client
	Token      string
}

// NewClient creates a new cfg__knowbase client.
func NewClient(baseURL string, httpClient *http.Client, token string) *Client {
	return &Client{
		BaseURL:    baseURL,
		HTTPClient: httpClient,
		Token:      token,
	}
}

// AdminChatListParams contains query parameters for AdminChatList.
type AdminChatListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// AdminDocumentsListParams contains query parameters for AdminDocumentsList.
type AdminDocumentsListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
	Status string `json:"status"`
}

// AdminSessionsListParams contains query parameters for AdminSessionsList.
type AdminSessionsListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// CategoriesListParams contains query parameters for CategoriesList.
type CategoriesListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// DocumentsListParams contains query parameters for DocumentsList.
type DocumentsListParams struct {
	Category string `json:"category"`
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
	Search string `json:"search"`
}

// SystemArchivesItemsListParams contains query parameters for SystemArchivesItemsList.
type SystemArchivesItemsListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// SystemArchivesListParams contains query parameters for SystemArchivesList.
type SystemArchivesListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// SystemArchivesSearchCreateParams contains query parameters for SystemArchivesSearchCreate.
type SystemArchivesSearchCreateParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// SystemChunksListParams contains query parameters for SystemChunksList.
type SystemChunksListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// SystemItemsChunksListParams contains query parameters for SystemItemsChunksList.
type SystemItemsChunksListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// SystemItemsListParams contains query parameters for SystemItemsList.
type SystemItemsListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}


// AdminChatCreate - Chat query endpoints.
func (c *Client) AdminChatCreate(ctx context.Context, body ChatResponseRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/chat/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminChatDestroy - Chat query endpoints.
func (c *Client) AdminChatDestroy(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/chat/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "DELETE",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "DELETE",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "DELETE", u, respBody)
	}


	return result, nil
}

// AdminChatHistoryRetrieve - Get chat history
func (c *Client) AdminChatHistoryRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/chat/{id}/history/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminChatList - Chat query endpoints.
func (c *Client) AdminChatList(ctx context.Context, params *AdminChatListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/chat/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminChatPartialUpdate - Chat query endpoints.
func (c *Client) AdminChatPartialUpdate(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/chat/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PATCH",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PATCH",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PATCH", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminChatQueryCreate - Process chat query with RAG
func (c *Client) AdminChatQueryCreate(ctx context.Context, body ChatQueryRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/chat/query/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminChatRetrieve - Chat query endpoints.
func (c *Client) AdminChatRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/chat/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminChatUpdate - Chat query endpoints.
func (c *Client) AdminChatUpdate(ctx context.Context, id string, body ChatResponseRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/chat/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PUT",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PUT",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PUT", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminDocumentsCreate - Upload new document
func (c *Client) AdminDocumentsCreate(ctx context.Context, body DocumentCreateRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminDocumentsDestroy - Delete document
func (c *Client) AdminDocumentsDestroy(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "DELETE",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "DELETE",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "DELETE", u, respBody)
	}


	return result, nil
}

// AdminDocumentsList - List user documents
func (c *Client) AdminDocumentsList(ctx context.Context, params *AdminDocumentsListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminDocumentsPartialUpdate - Document management endpoints - Admin only.
func (c *Client) AdminDocumentsPartialUpdate(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PATCH",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PATCH",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PATCH", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminDocumentsReprocessCreate - Reprocess document
func (c *Client) AdminDocumentsReprocessCreate(ctx context.Context, id string, body DocumentRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/{id}/reprocess/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminDocumentsRetrieve - Get document details
func (c *Client) AdminDocumentsRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminDocumentsStatsRetrieve - Get processing statistics
func (c *Client) AdminDocumentsStatsRetrieve(ctx context.Context) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/stats/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminDocumentsStatusRetrieve - Get document processing status
func (c *Client) AdminDocumentsStatusRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/{id}/status/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminDocumentsUpdate - Document management endpoints - Admin only.
func (c *Client) AdminDocumentsUpdate(ctx context.Context, id string, body DocumentRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/documents/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PUT",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PUT",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PUT", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminSessionsActivateCreate - Activate chat session
func (c *Client) AdminSessionsActivateCreate(ctx context.Context, id string, body ChatSessionRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/sessions/{id}/activate/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminSessionsArchiveCreate - Archive chat session
func (c *Client) AdminSessionsArchiveCreate(ctx context.Context, id string, body ChatSessionRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/sessions/{id}/archive/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminSessionsCreate - Create new chat session
func (c *Client) AdminSessionsCreate(ctx context.Context, body ChatSessionCreateRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/sessions/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminSessionsDestroy - Chat session management endpoints.
func (c *Client) AdminSessionsDestroy(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/sessions/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "DELETE",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "DELETE",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "DELETE", u, respBody)
	}


	return result, nil
}

// AdminSessionsList - List user chat sessions
func (c *Client) AdminSessionsList(ctx context.Context, params *AdminSessionsListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/sessions/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminSessionsPartialUpdate - Chat session management endpoints.
func (c *Client) AdminSessionsPartialUpdate(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/sessions/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PATCH",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PATCH",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PATCH", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminSessionsRetrieve - Chat session management endpoints.
func (c *Client) AdminSessionsRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/sessions/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// AdminSessionsUpdate - Chat session management endpoints.
func (c *Client) AdminSessionsUpdate(ctx context.Context, id string, body ChatSessionRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/admin/sessions/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PUT",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PUT",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PUT", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// CategoriesList - List public categories
func (c *Client) CategoriesList(ctx context.Context, params *CategoriesListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/categories/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// CategoriesRetrieve - Get public category details
func (c *Client) CategoriesRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/categories/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// DocumentsList - List public documents
func (c *Client) DocumentsList(ctx context.Context, params *DocumentsListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/documents/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// DocumentsRetrieve - Get public document details
func (c *Client) DocumentsRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/documents/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesCreate - Upload and process archive
func (c *Client) SystemArchivesCreate(ctx context.Context, body map[string]interface{}) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesDestroy - Document archive management endpoints - Admin only.
func (c *Client) SystemArchivesDestroy(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "DELETE",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "DELETE",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "DELETE", u, respBody)
	}


	return result, nil
}

// SystemArchivesFileTreeRetrieve - Get archive file tree
func (c *Client) SystemArchivesFileTreeRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/{id}/file_tree/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesItemsList - Get archive items
func (c *Client) SystemArchivesItemsList(ctx context.Context, id string, params *SystemArchivesItemsListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/{id}/items/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesList - Document archive management endpoints - Admin only.
func (c *Client) SystemArchivesList(ctx context.Context, params *SystemArchivesListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesPartialUpdate - Document archive management endpoints - Admin only.
func (c *Client) SystemArchivesPartialUpdate(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PATCH",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PATCH",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PATCH", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesRetrieve - Document archive management endpoints - Admin only.
func (c *Client) SystemArchivesRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesRevectorizeCreate - Re-vectorize chunks
func (c *Client) SystemArchivesRevectorizeCreate(ctx context.Context, body ChunkRevectorizationRequestRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/revectorize/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesSearchCreate - Search archive chunks
func (c *Client) SystemArchivesSearchCreate(ctx context.Context, id string, params *SystemArchivesSearchCreateParams, body ArchiveSearchRequestRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/{id}/search/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesStatisticsRetrieve - Get archive statistics
func (c *Client) SystemArchivesStatisticsRetrieve(ctx context.Context) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/statistics/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesUpdate - Document archive management endpoints - Admin only.
func (c *Client) SystemArchivesUpdate(ctx context.Context, id string, body DocumentArchiveRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PUT",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PUT",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PUT", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemArchivesVectorizationStatsRetrieve - Get vectorization statistics
func (c *Client) SystemArchivesVectorizationStatsRetrieve(ctx context.Context) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/archives/vectorization_stats/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemChunksContextRetrieve - Get chunk context
func (c *Client) SystemChunksContextRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/chunks/{id}/context/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemChunksCreate - Archive item chunk management endpoints - Admin only.
func (c *Client) SystemChunksCreate(ctx context.Context, body ArchiveItemChunkRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/chunks/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemChunksDestroy - Archive item chunk management endpoints - Admin only.
func (c *Client) SystemChunksDestroy(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/chunks/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "DELETE",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "DELETE",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "DELETE", u, respBody)
	}


	return result, nil
}

// SystemChunksList - Archive item chunk management endpoints - Admin only.
func (c *Client) SystemChunksList(ctx context.Context, params *SystemChunksListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/chunks/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemChunksPartialUpdate - Archive item chunk management endpoints - Admin only.
func (c *Client) SystemChunksPartialUpdate(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/chunks/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PATCH",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PATCH",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PATCH", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemChunksRetrieve - Archive item chunk management endpoints - Admin only.
func (c *Client) SystemChunksRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/chunks/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemChunksUpdate - Archive item chunk management endpoints - Admin only.
func (c *Client) SystemChunksUpdate(ctx context.Context, id string, body ArchiveItemChunkRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/chunks/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PUT",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PUT",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PUT", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemChunksVectorizeCreate - Vectorize chunk
func (c *Client) SystemChunksVectorizeCreate(ctx context.Context, id string, body ArchiveItemChunkRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/chunks/{id}/vectorize/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemItemsChunksList - Get item chunks
func (c *Client) SystemItemsChunksList(ctx context.Context, id string, params *SystemItemsChunksListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/items/{id}/chunks/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemItemsContentRetrieve - Get item content
func (c *Client) SystemItemsContentRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/items/{id}/content/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemItemsCreate - Archive item management endpoints - Admin only.
func (c *Client) SystemItemsCreate(ctx context.Context, body ArchiveItemRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/items/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemItemsDestroy - Archive item management endpoints - Admin only.
func (c *Client) SystemItemsDestroy(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/items/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "DELETE",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "DELETE",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "DELETE", u, respBody)
	}


	return result, nil
}

// SystemItemsList - Archive item management endpoints - Admin only.
func (c *Client) SystemItemsList(ctx context.Context, params *SystemItemsListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/items/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemItemsPartialUpdate - Archive item management endpoints - Admin only.
func (c *Client) SystemItemsPartialUpdate(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/items/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PATCH",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PATCH",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PATCH", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemItemsRetrieve - Archive item management endpoints - Admin only.
func (c *Client) SystemItemsRetrieve(ctx context.Context, id string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/items/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// SystemItemsUpdate - Archive item management endpoints - Admin only.
func (c *Client) SystemItemsUpdate(ctx context.Context, id string, body ArchiveItemRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/knowbase/system/items/{id}/"
	path = strings.ReplaceAll(path, "{id}", fmt.Sprintf("%v", id))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PUT",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PUT",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PUT", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

