// Code generated by django-cfg/django_client - DO NOT EDIT.
// Generated at: 2025-10-27T19:13:24.692931

package cfg__knowbase

import (
	"cfg/types"
	"time"
)

// Archive item serializer.
type ArchiveItem struct {
	ID string `json:"id"`
	// Path within archive
	RelativePath string `json:"relative_path"`
	// Item name
	ItemName string `json:"item_name"`
	// MIME type
	ItemType string `json:"item_type"`
	// Content classification
	// 
	// * `document` - Document
	// * `code` - Code
	// * `image` - Image
	// * `data` - Data
	// * `archive` - Archive
	// * `unknown` - Unknown
	ContentType types.ArchiveitemContentType `json:"content_type"`
	// Item size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
	// Whether item can be processed for chunks
	IsProcessable bool `json:"is_processable"`
	// Programming language or document language
	Language string `json:"language"`
	// Character encoding
	Encoding string `json:"encoding"`
	// Number of chunks created
	ChunksCount int64 `json:"chunks_count"`
	// Total tokens in all chunks
	TotalTokens int64 `json:"total_tokens"`
	// Processing cost for this item
	ProcessingCost float64 `json:"processing_cost"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Archive item chunk serializer.
type ArchiveItemChunk struct {
	ID string `json:"id"`
	// Chunk text content
	Content string `json:"content"`
	// Sequential chunk number within item
	ChunkIndex int64 `json:"chunk_index"`
	// Type of content in chunk
	// 
	// * `text` - Text
	// * `code` - Code
	// * `heading` - Heading
	// * `metadata` - Metadata
	// * `table` - Table
	// * `list` - List
	ChunkType *types.ArchiveitemchunkChunkType `json:"chunk_type,omitempty"`
	// Number of tokens in chunk
	TokenCount int64 `json:"token_count"`
	// Number of characters in chunk
	CharacterCount int64 `json:"character_count"`
	// Model used for embedding generation
	EmbeddingModel string `json:"embedding_model"`
	// Cost in USD for embedding generation
	EmbeddingCost float64 `json:"embedding_cost"`
	// Get context summary for display.
	ContextSummary map[string]interface{} `json:"context_summary"`
	CreatedAt time.Time `json:"created_at"`
}

// Detailed chunk serializer with full context.
type ArchiveItemChunkDetail struct {
	ID string `json:"id"`
	// Chunk text content
	Content string `json:"content"`
	// Sequential chunk number within item
	ChunkIndex int64 `json:"chunk_index"`
	// Type of content in chunk
	// 
	// * `text` - Text
	// * `code` - Code
	// * `heading` - Heading
	// * `metadata` - Metadata
	// * `table` - Table
	// * `list` - List
	ChunkType *types.ArchiveitemchunkdetailChunkType `json:"chunk_type,omitempty"`
	// Number of tokens in chunk
	TokenCount int64 `json:"token_count"`
	// Number of characters in chunk
	CharacterCount int64 `json:"character_count"`
	// Model used for embedding generation
	EmbeddingModel string `json:"embedding_model"`
	// Cost in USD for embedding generation
	EmbeddingCost float64 `json:"embedding_cost"`
	// Get context summary for display.
	ContextSummary map[string]interface{} `json:"context_summary"`
	CreatedAt time.Time `json:"created_at"`
	ContextMetadata string `json:"context_metadata"`
}

// Archive item chunk serializer.
type ArchiveItemChunkRequest struct {
	// Chunk text content
	Content string `json:"content"`
	// Sequential chunk number within item
	ChunkIndex int64 `json:"chunk_index"`
	// Type of content in chunk
	// 
	// * `text` - Text
	// * `code` - Code
	// * `heading` - Heading
	// * `metadata` - Metadata
	// * `table` - Table
	// * `list` - List
	ChunkType *types.ArchiveitemchunkrequestChunkType `json:"chunk_type,omitempty"`
}

// Detailed archive item serializer with content.
type ArchiveItemDetail struct {
	ID string `json:"id"`
	// Path within archive
	RelativePath string `json:"relative_path"`
	// Item name
	ItemName string `json:"item_name"`
	// MIME type
	ItemType string `json:"item_type"`
	// Content classification
	// 
	// * `document` - Document
	// * `code` - Code
	// * `image` - Image
	// * `data` - Data
	// * `archive` - Archive
	// * `unknown` - Unknown
	ContentType types.ArchiveitemdetailContentType `json:"content_type"`
	// Item size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
	// Whether item can be processed for chunks
	IsProcessable bool `json:"is_processable"`
	// Programming language or document language
	Language string `json:"language"`
	// Character encoding
	Encoding string `json:"encoding"`
	// Number of chunks created
	ChunksCount int64 `json:"chunks_count"`
	// Total tokens in all chunks
	TotalTokens int64 `json:"total_tokens"`
	// Processing cost for this item
	ProcessingCost float64 `json:"processing_cost"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	RawContent string `json:"raw_content"`
	Metadata string `json:"metadata"`
}

// Archive item serializer.
type ArchiveItemRequest struct {
	// Path within archive
	RelativePath string `json:"relative_path"`
	// Item name
	ItemName string `json:"item_name"`
	// MIME type
	ItemType string `json:"item_type"`
	// Item size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
}

// Archive processing result serializer.
type ArchiveProcessingResult struct {
	ArchiveID string `json:"archive_id"`
	Status string `json:"status"`
	ProcessingTimeMs int64 `json:"processing_time_ms"`
	ItemsProcessed int64 `json:"items_processed"`
	ChunksCreated int64 `json:"chunks_created"`
	VectorizedChunks int64 `json:"vectorized_chunks"`
	TotalCostUsd float64 `json:"total_cost_usd"`
	ErrorMessage string `json:"error_message"`
}

// Archive search request serializer.
type ArchiveSearchRequestRequest struct {
	// Search query
	Query string `json:"query"`
	// Filter by content types
	ContentTypes []types.ArchivesearchrequestrequestContentTypesItems `json:"content_types,omitempty"`
	// Filter by programming languages
	Languages []string `json:"languages,omitempty"`
	// Filter by chunk types
	ChunkTypes []types.ArchivesearchrequestrequestChunkTypesItems `json:"chunk_types,omitempty"`
	// Search within specific archives
	ArchiveIds []string `json:"archive_ids,omitempty"`
	// Maximum number of results
	Limit *int64 `json:"limit,omitempty"`
	// Minimum similarity threshold
	SimilarityThreshold *float64 `json:"similarity_threshold,omitempty"`
}

// Archive search result serializer.
type ArchiveSearchResult struct {
	Chunk ArchiveItemChunk `json:"chunk"`
	SimilarityScore float64 `json:"similarity_score"`
	ContextSummary map[string]interface{} `json:"context_summary"`
	ArchiveInfo map[string]interface{} `json:"archive_info"`
	ItemInfo map[string]interface{} `json:"item_info"`
}

// Archive statistics serializer.
type ArchiveStatistics struct {
	TotalArchives int64 `json:"total_archives"`
	ProcessedArchives int64 `json:"processed_archives"`
	FailedArchives int64 `json:"failed_archives"`
	TotalItems int64 `json:"total_items"`
	TotalChunks int64 `json:"total_chunks"`
	TotalTokens int64 `json:"total_tokens"`
	TotalCost float64 `json:"total_cost"`
	AvgProcessingTime float64 `json:"avg_processing_time"`
	AvgItemsPerArchive float64 `json:"avg_items_per_archive"`
	AvgChunksPerArchive float64 `json:"avg_chunks_per_archive"`
}

// Chat history response serializer.
type ChatHistory struct {
	SessionID string `json:"session_id"`
	Messages []ChatMessage `json:"messages"`
	TotalMessages int64 `json:"total_messages"`
}

// Chat message response serializer.
type ChatMessage struct {
	ID string `json:"id"`
	// Message sender role
	// 
	// * `user` - User
	// * `assistant` - Assistant
	// * `system` - System
	Role types.ChatmessageRole `json:"role"`
	// Message content
	Content string `json:"content"`
	// Tokens used for this message
	TokensUsed *int64 `json:"tokens_used,omitempty"`
	CostUsd float64 `json:"cost_usd"`
	// Processing time in milliseconds
	ProcessingTimeMs *int64 `json:"processing_time_ms,omitempty"`
	CreatedAt time.Time `json:"created_at"`
	// IDs of chunks used for context
	ContextChunks *string `json:"context_chunks,omitempty"`
}

// Chat query request serializer.
type ChatQueryRequest struct {
	// Chat session ID (creates new if not provided)
	SessionID *string `json:"session_id,omitempty"`
	// User query
	Query string `json:"query"`
	// Maximum response tokens
	MaxTokens *int64 `json:"max_tokens,omitempty"`
	// Include source documents in response
	IncludeSources *bool `json:"include_sources,omitempty"`
}

// Chat response serializer.
type ChatResponse struct {
	MessageID string `json:"message_id"`
	Content string `json:"content"`
	TokensUsed int64 `json:"tokens_used"`
	CostUsd float64 `json:"cost_usd"`
	ProcessingTimeMs int64 `json:"processing_time_ms"`
	ModelUsed string `json:"model_used"`
	Sources []ChatSource `json:"sources,omitempty"`
}

// Chat response serializer.
type ChatResponseRequest struct {
	MessageID string `json:"message_id"`
	Content string `json:"content"`
	TokensUsed int64 `json:"tokens_used"`
	CostUsd float64 `json:"cost_usd"`
	ProcessingTimeMs int64 `json:"processing_time_ms"`
	ModelUsed string `json:"model_used"`
	Sources []ChatSourceRequest `json:"sources,omitempty"`
}

// Chat session response serializer.
type ChatSession struct {
	ID string `json:"id"`
	// Session title (auto-generated if empty)
	Title *string `json:"title,omitempty"`
	// Whether session accepts new messages
	IsActive *bool `json:"is_active,omitempty"`
	MessagesCount *int64 `json:"messages_count,omitempty"`
	TotalTokensUsed *int64 `json:"total_tokens_used,omitempty"`
	TotalCostUsd float64 `json:"total_cost_usd"`
	// LLM model used for this session
	ModelName *string `json:"model_name,omitempty"`
	// Temperature setting for LLM
	Temperature *float64 `json:"temperature,omitempty"`
	// Maximum chunks to include in context
	MaxContextChunks *int64 `json:"max_context_chunks,omitempty"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Chat session creation request serializer.
type ChatSessionCreateRequest struct {
	// Session title
	Title *string `json:"title,omitempty"`
	// LLM model to use
	ModelName *string `json:"model_name,omitempty"`
	// Response creativity
	Temperature *float64 `json:"temperature,omitempty"`
	// Maximum context chunks
	MaxContextChunks *int64 `json:"max_context_chunks,omitempty"`
}

// Chat session response serializer.
type ChatSessionRequest struct {
	// Session title (auto-generated if empty)
	Title *string `json:"title,omitempty"`
	// Whether session accepts new messages
	IsActive *bool `json:"is_active,omitempty"`
	MessagesCount *int64 `json:"messages_count,omitempty"`
	TotalTokensUsed *int64 `json:"total_tokens_used,omitempty"`
	// LLM model used for this session
	ModelName *string `json:"model_name,omitempty"`
	// Temperature setting for LLM
	Temperature *float64 `json:"temperature,omitempty"`
	// Maximum chunks to include in context
	MaxContextChunks *int64 `json:"max_context_chunks,omitempty"`
}

// Chat source document information serializer.
type ChatSource struct {
	DocumentTitle string `json:"document_title"`
	ChunkContent string `json:"chunk_content"`
	Similarity float64 `json:"similarity"`
}

// Chat source document information serializer.
type ChatSourceRequest struct {
	DocumentTitle string `json:"document_title"`
	ChunkContent string `json:"chunk_content"`
	Similarity float64 `json:"similarity"`
}

// Chunk re-vectorization request serializer.
type ChunkRevectorizationRequestRequest struct {
	// List of chunk IDs to re-vectorize
	ChunkIds []string `json:"chunk_ids"`
	// Force re-vectorization even if already vectorized
	Force *bool `json:"force,omitempty"`
}

// Document response serializer.
type Document struct {
	ID string `json:"id"`
	// Document title
	Title string `json:"title"`
	// MIME type of original file
	FileType *string `json:"file_type,omitempty"`
	// Original file size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
	ProcessingStatus string `json:"processing_status"`
	ChunksCount int64 `json:"chunks_count"`
	TotalTokens int64 `json:"total_tokens"`
	TotalCostUsd float64 `json:"total_cost_usd"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	ProcessingStartedAt time.Time `json:"processing_started_at"`
	ProcessingCompletedAt time.Time `json:"processing_completed_at"`
	ProcessingError string `json:"processing_error"`
	// Additional document metadata
	Metadata *string `json:"metadata,omitempty"`
}

// Document archive serializer.
type DocumentArchive struct {
	ID string `json:"id"`
	// Archive title
	Title string `json:"title"`
	// Archive description
	Description *string `json:"description,omitempty"`
	Categories []DocumentCategory `json:"categories"`
	// Whether this archive is publicly accessible
	IsPublic *bool `json:"is_public,omitempty"`
	// Uploaded archive file
	ArchiveFile string `json:"archive_file"`
	// Original uploaded filename
	OriginalFilename string `json:"original_filename"`
	// Archive size in bytes
	FileSize int64 `json:"file_size"`
	// Archive format
	// 
	// * `zip` - ZIP
	// * `tar` - TAR
	// * `tar.gz` - TAR GZ
	// * `tar.bz2` - TAR BZ2
	ArchiveType types.DocumentarchiveArchiveType `json:"archive_type"`
	// * `pending` - Pending
	// * `processing` - Processing
	// * `completed` - Completed
	// * `failed` - Failed
	// * `cancelled` - Cancelled
	ProcessingStatus types.DocumentarchiveProcessingStatus `json:"processing_status"`
	// When processing completed
	ProcessedAt time.Time `json:"processed_at"`
	// Processing time in milliseconds
	ProcessingDurationMs int64 `json:"processing_duration_ms"`
	// Error message if processing failed
	ProcessingError string `json:"processing_error"`
	// Total items in archive
	TotalItems int64 `json:"total_items"`
	// Successfully processed items
	ProcessedItems int64 `json:"processed_items"`
	// Total chunks created
	TotalChunks int64 `json:"total_chunks"`
	// Chunks with embeddings
	VectorizedChunks int64 `json:"vectorized_chunks"`
	// Total tokens across all chunks
	TotalTokens int64 `json:"total_tokens"`
	// Total processing cost in USD
	TotalCostUsd float64 `json:"total_cost_usd"`
	// Calculate processing progress as percentage.
	ProcessingProgress float64 `json:"processing_progress"`
	// Calculate vectorization progress as percentage.
	VectorizationProgress float64 `json:"vectorization_progress"`
	// Check if archive processing is completed.
	IsProcessed bool `json:"is_processed"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Detailed archive serializer with items.
type DocumentArchiveDetail struct {
	ID string `json:"id"`
	// Archive title
	Title string `json:"title"`
	// Archive description
	Description *string `json:"description,omitempty"`
	Categories []DocumentCategory `json:"categories"`
	// Whether this archive is publicly accessible
	IsPublic *bool `json:"is_public,omitempty"`
	// Uploaded archive file
	ArchiveFile string `json:"archive_file"`
	// Original uploaded filename
	OriginalFilename string `json:"original_filename"`
	// Archive size in bytes
	FileSize int64 `json:"file_size"`
	// Archive format
	// 
	// * `zip` - ZIP
	// * `tar` - TAR
	// * `tar.gz` - TAR GZ
	// * `tar.bz2` - TAR BZ2
	ArchiveType types.DocumentarchivedetailArchiveType `json:"archive_type"`
	// * `pending` - Pending
	// * `processing` - Processing
	// * `completed` - Completed
	// * `failed` - Failed
	// * `cancelled` - Cancelled
	ProcessingStatus types.DocumentarchivedetailProcessingStatus `json:"processing_status"`
	// When processing completed
	ProcessedAt time.Time `json:"processed_at"`
	// Processing time in milliseconds
	ProcessingDurationMs int64 `json:"processing_duration_ms"`
	// Error message if processing failed
	ProcessingError string `json:"processing_error"`
	// Total items in archive
	TotalItems int64 `json:"total_items"`
	// Successfully processed items
	ProcessedItems int64 `json:"processed_items"`
	// Total chunks created
	TotalChunks int64 `json:"total_chunks"`
	// Chunks with embeddings
	VectorizedChunks int64 `json:"vectorized_chunks"`
	// Total tokens across all chunks
	TotalTokens int64 `json:"total_tokens"`
	// Total processing cost in USD
	TotalCostUsd float64 `json:"total_cost_usd"`
	// Calculate processing progress as percentage.
	ProcessingProgress float64 `json:"processing_progress"`
	// Calculate vectorization progress as percentage.
	VectorizationProgress float64 `json:"vectorization_progress"`
	// Check if archive processing is completed.
	IsProcessed bool `json:"is_processed"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Items []ArchiveItem `json:"items"`
	// Get hierarchical file tree.
	FileTree map[string]interface{} `json:"file_tree"`
	// Additional archive metadata
	Metadata *string `json:"metadata,omitempty"`
}

// Simplified archive serializer for list views.
type DocumentArchiveList struct {
	ID string `json:"id"`
	// Archive title
	Title string `json:"title"`
	// Archive description
	Description string `json:"description"`
	Categories []DocumentCategory `json:"categories"`
	// Whether this archive is publicly accessible
	IsPublic bool `json:"is_public"`
	// Original uploaded filename
	OriginalFilename string `json:"original_filename"`
	// Archive size in bytes
	FileSize int64 `json:"file_size"`
	// Archive format
	// 
	// * `zip` - ZIP
	// * `tar` - TAR
	// * `tar.gz` - TAR GZ
	// * `tar.bz2` - TAR BZ2
	ArchiveType types.DocumentarchivelistArchiveType `json:"archive_type"`
	// * `pending` - Pending
	// * `processing` - Processing
	// * `completed` - Completed
	// * `failed` - Failed
	// * `cancelled` - Cancelled
	ProcessingStatus types.DocumentarchivelistProcessingStatus `json:"processing_status"`
	// When processing completed
	ProcessedAt time.Time `json:"processed_at"`
	// Total items in archive
	TotalItems int64 `json:"total_items"`
	// Total chunks created
	TotalChunks int64 `json:"total_chunks"`
	// Total processing cost in USD
	TotalCostUsd float64 `json:"total_cost_usd"`
	// Calculate processing progress as percentage.
	ProcessingProgress float64 `json:"processing_progress"`
	CreatedAt time.Time `json:"created_at"`
}

// Document archive serializer.
type DocumentArchiveRequest struct {
	// Archive title
	Title string `json:"title"`
	// Archive description
	Description *string `json:"description,omitempty"`
	// Whether this archive is publicly accessible
	IsPublic *bool `json:"is_public,omitempty"`
}

// Document category serializer.
type DocumentCategory struct {
	ID string `json:"id"`
	// Category name
	Name string `json:"name"`
	// Category description
	Description *string `json:"description,omitempty"`
	// Whether documents in this category are publicly accessible
	IsPublic *bool `json:"is_public,omitempty"`
	CreatedAt time.Time `json:"created_at"`
}

// Document creation request serializer.
type DocumentCreateRequest struct {
	// Document title
	Title string `json:"title"`
	// Document content
	Content string `json:"content"`
	// MIME type
	FileType *string `json:"file_type,omitempty"`
	// Additional metadata
	Metadata *string `json:"metadata,omitempty"`
}

// Document processing status serializer.
type DocumentProcessingStatus struct {
	ID string `json:"id"`
	Status string `json:"status"`
	Progress string `json:"progress"`
	Error *string `json:"error,omitempty"`
	ProcessingTimeSeconds *float64 `json:"processing_time_seconds,omitempty"`
}

// Document response serializer.
type DocumentRequest struct {
	// Document title
	Title string `json:"title"`
	// MIME type of original file
	FileType *string `json:"file_type,omitempty"`
	// Original file size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
	// Additional document metadata
	Metadata *string `json:"metadata,omitempty"`
}

// Document processing statistics serializer.
type DocumentStats struct {
	TotalDocuments int64 `json:"total_documents"`
	CompletedDocuments int64 `json:"completed_documents"`
	ProcessingSuccessRate float64 `json:"processing_success_rate"`
	TotalChunks int64 `json:"total_chunks"`
	TotalTokens int64 `json:"total_tokens"`
	TotalCostUsd float64 `json:"total_cost_usd"`
	AvgProcessingTimeSeconds float64 `json:"avg_processing_time_seconds"`
}

// PaginatedArchiveItemChunkList model.
type PaginatedArchiveItemChunkList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []ArchiveItemChunk `json:"results"`
}

// PaginatedArchiveItemList model.
type PaginatedArchiveItemList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []ArchiveItem `json:"results"`
}

// PaginatedArchiveSearchResultList model.
type PaginatedArchiveSearchResultList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []ArchiveSearchResult `json:"results"`
}

// PaginatedChatResponseList model.
type PaginatedChatResponseList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []ChatResponse `json:"results"`
}

// PaginatedChatSessionList model.
type PaginatedChatSessionList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []ChatSession `json:"results"`
}

// PaginatedDocumentArchiveListList model.
type PaginatedDocumentArchiveListList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []DocumentArchiveList `json:"results"`
}

// PaginatedDocumentList model.
type PaginatedDocumentList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []Document `json:"results"`
}

// PaginatedPublicCategoryList model.
type PaginatedPublicCategoryList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []PublicCategory `json:"results"`
}

// PaginatedPublicDocumentListList model.
type PaginatedPublicDocumentListList struct {
	// Total number of items across all pages
	Count int64 `json:"count"`
	// Current page number (1-based)
	Page int64 `json:"page"`
	// Total number of pages
	Pages int64 `json:"pages"`
	// Number of items per page
	PageSize int64 `json:"page_size"`
	// Whether there is a next page
	HasNext bool `json:"has_next"`
	// Whether there is a previous page
	HasPrevious bool `json:"has_previous"`
	// Next page number (null if no next page)
	NextPage *int64 `json:"next_page,omitempty"`
	// Previous page number (null if no previous page)
	PreviousPage *int64 `json:"previous_page,omitempty"`
	// Array of items for current page
	Results []PublicDocumentList `json:"results"`
}

// Archive item chunk serializer.
type PatchedArchiveItemChunkRequest struct {
	// Chunk text content
	Content *string `json:"content,omitempty"`
	// Sequential chunk number within item
	ChunkIndex *int64 `json:"chunk_index,omitempty"`
	// Type of content in chunk
	// 
	// * `text` - Text
	// * `code` - Code
	// * `heading` - Heading
	// * `metadata` - Metadata
	// * `table` - Table
	// * `list` - List
	ChunkType *types.PatchedarchiveitemchunkrequestChunkType `json:"chunk_type,omitempty"`
}

// Archive item serializer.
type PatchedArchiveItemRequest struct {
	// Path within archive
	RelativePath *string `json:"relative_path,omitempty"`
	// Item name
	ItemName *string `json:"item_name,omitempty"`
	// MIME type
	ItemType *string `json:"item_type,omitempty"`
	// Item size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
}

// Chat response serializer.
type PatchedChatResponseRequest struct {
	MessageID *string `json:"message_id,omitempty"`
	Content *string `json:"content,omitempty"`
	TokensUsed *int64 `json:"tokens_used,omitempty"`
	CostUsd *float64 `json:"cost_usd,omitempty"`
	ProcessingTimeMs *int64 `json:"processing_time_ms,omitempty"`
	ModelUsed *string `json:"model_used,omitempty"`
	Sources []ChatSourceRequest `json:"sources,omitempty"`
}

// Chat session response serializer.
type PatchedChatSessionRequest struct {
	// Session title (auto-generated if empty)
	Title *string `json:"title,omitempty"`
	// Whether session accepts new messages
	IsActive *bool `json:"is_active,omitempty"`
	MessagesCount *int64 `json:"messages_count,omitempty"`
	TotalTokensUsed *int64 `json:"total_tokens_used,omitempty"`
	// LLM model used for this session
	ModelName *string `json:"model_name,omitempty"`
	// Temperature setting for LLM
	Temperature *float64 `json:"temperature,omitempty"`
	// Maximum chunks to include in context
	MaxContextChunks *int64 `json:"max_context_chunks,omitempty"`
}

// Document archive serializer.
type PatchedDocumentArchiveRequest struct {
	// Archive title
	Title *string `json:"title,omitempty"`
	// Archive description
	Description *string `json:"description,omitempty"`
	// Whether this archive is publicly accessible
	IsPublic *bool `json:"is_public,omitempty"`
}

// Document response serializer.
type PatchedDocumentRequest struct {
	// Document title
	Title *string `json:"title,omitempty"`
	// MIME type of original file
	FileType *string `json:"file_type,omitempty"`
	// Original file size in bytes
	FileSize *int64 `json:"file_size,omitempty"`
	// Additional document metadata
	Metadata *string `json:"metadata,omitempty"`
}

// Public category serializer.
type PublicCategory struct {
	ID string `json:"id"`
	// Category name
	Name string `json:"name"`
	// Category description
	Description *string `json:"description,omitempty"`
}

// Public document detail serializer - only essential data for clients.
type PublicDocument struct {
	ID string `json:"id"`
	// Document title
	Title string `json:"title"`
	// Full document content
	Content string `json:"content"`
	Category PublicCategory `json:"category"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Public document list serializer - minimal fields for listing.
type PublicDocumentList struct {
	ID string `json:"id"`
	// Document title
	Title string `json:"title"`
	Category PublicCategory `json:"category"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Vectorization result serializer.
type VectorizationResult struct {
	VectorizedCount int64 `json:"vectorized_count"`
	FailedCount int64 `json:"failed_count"`
	TotalTokens int64 `json:"total_tokens"`
	TotalCost float64 `json:"total_cost"`
	SuccessRate float64 `json:"success_rate"`
	Errors []string `json:"errors"`
}

// Vectorization statistics serializer.
type VectorizationStatistics struct {
	TotalChunks int64 `json:"total_chunks"`
	VectorizedChunks int64 `json:"vectorized_chunks"`
	PendingChunks int64 `json:"pending_chunks"`
	VectorizationRate float64 `json:"vectorization_rate"`
	TotalTokens int64 `json:"total_tokens"`
	TotalCost float64 `json:"total_cost"`
	AvgTokensPerChunk float64 `json:"avg_tokens_per_chunk"`
	AvgCostPerChunk float64 `json:"avg_cost_per_chunk"`
}

