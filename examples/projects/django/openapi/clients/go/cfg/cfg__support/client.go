// Code generated by django-cfg/django_client - DO NOT EDIT.
// Generated at: 2025-10-28T07:47:34.550766

package cfg__support

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	// Import shared package for error types
	"cfg/shared"
)

// Client provides access to cfg__support operations.
type Client struct {
	BaseURL    string
	HTTPClient *http.Client
	Token      string
}

// NewClient creates a new cfg__support client.
func NewClient(baseURL string, httpClient *http.Client, token string) *Client {
	return &Client{
		BaseURL:    baseURL,
		HTTPClient: httpClient,
		Token:      token,
	}
}

// TicketsListParams contains query parameters for TicketsList.
type TicketsListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}

// TicketsMessagesListParams contains query parameters for TicketsMessagesList.
type TicketsMessagesListParams struct {
	Page int64 `json:"page"`
	PageSize int64 `json:"page_size"`
}


// TicketsCreate - ViewSet for managing support tickets.
func (c *Client) TicketsCreate(ctx context.Context, body TicketRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/"


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsDestroy - ViewSet for managing support tickets.
func (c *Client) TicketsDestroy(ctx context.Context, uuid string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{uuid}/"
	path = strings.ReplaceAll(path, "{uuid}", fmt.Sprintf("%v", uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "DELETE",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "DELETE",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "DELETE", u, respBody)
	}


	return result, nil
}

// TicketsList - ViewSet for managing support tickets.
func (c *Client) TicketsList(ctx context.Context, params *TicketsListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/"

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsMessagesCreate - ViewSet for managing support messages.
func (c *Client) TicketsMessagesCreate(ctx context.Context, ticket_uuid string, body MessageCreateRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{ticket_uuid}/messages/"
	path = strings.ReplaceAll(path, "{ticket_uuid}", fmt.Sprintf("%v", ticket_uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "POST",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "POST",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "POST", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsMessagesDestroy - ViewSet for managing support messages.
func (c *Client) TicketsMessagesDestroy(ctx context.Context, ticket_uuid string, uuid string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{ticket_uuid}/messages/{uuid}/"
	path = strings.ReplaceAll(path, "{ticket_uuid}", fmt.Sprintf("%v", ticket_uuid))
	path = strings.ReplaceAll(path, "{uuid}", fmt.Sprintf("%v", uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "DELETE", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "DELETE",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "DELETE",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "DELETE", u, respBody)
	}


	return result, nil
}

// TicketsMessagesList - ViewSet for managing support messages.
func (c *Client) TicketsMessagesList(ctx context.Context, ticket_uuid string, params *TicketsMessagesListParams) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{ticket_uuid}/messages/"
	path = strings.ReplaceAll(path, "{ticket_uuid}", fmt.Sprintf("%v", ticket_uuid))

	// Add query parameters
	if params != nil {
		query := url.Values{}
		// TODO: Add query parameter marshaling based on struct fields
		path = path + "?" + query.Encode()
	}

	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsMessagesPartialUpdate - ViewSet for managing support messages.
func (c *Client) TicketsMessagesPartialUpdate(ctx context.Context, ticket_uuid string, uuid string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{ticket_uuid}/messages/{uuid}/"
	path = strings.ReplaceAll(path, "{ticket_uuid}", fmt.Sprintf("%v", ticket_uuid))
	path = strings.ReplaceAll(path, "{uuid}", fmt.Sprintf("%v", uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PATCH",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PATCH",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PATCH", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsMessagesRetrieve - ViewSet for managing support messages.
func (c *Client) TicketsMessagesRetrieve(ctx context.Context, ticket_uuid string, uuid string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{ticket_uuid}/messages/{uuid}/"
	path = strings.ReplaceAll(path, "{ticket_uuid}", fmt.Sprintf("%v", ticket_uuid))
	path = strings.ReplaceAll(path, "{uuid}", fmt.Sprintf("%v", uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsMessagesUpdate - ViewSet for managing support messages.
func (c *Client) TicketsMessagesUpdate(ctx context.Context, ticket_uuid string, uuid string, body MessageRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{ticket_uuid}/messages/{uuid}/"
	path = strings.ReplaceAll(path, "{ticket_uuid}", fmt.Sprintf("%v", ticket_uuid))
	path = strings.ReplaceAll(path, "{uuid}", fmt.Sprintf("%v", uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PUT",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PUT",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PUT", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsPartialUpdate - ViewSet for managing support tickets.
func (c *Client) TicketsPartialUpdate(ctx context.Context, uuid string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{uuid}/"
	path = strings.ReplaceAll(path, "{uuid}", fmt.Sprintf("%v", uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PATCH", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PATCH",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PATCH",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PATCH", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsRetrieve - ViewSet for managing support tickets.
func (c *Client) TicketsRetrieve(ctx context.Context, uuid string) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{uuid}/"
	path = strings.ReplaceAll(path, "{uuid}", fmt.Sprintf("%v", uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "GET",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "GET",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "GET", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

// TicketsUpdate - ViewSet for managing support tickets.
func (c *Client) TicketsUpdate(ctx context.Context, uuid string, body TicketRequest) (interface{}, error) {
	var result interface{}

	// Build URL
	path := "/cfg/support/tickets/{uuid}/"
	path = strings.ReplaceAll(path, "{uuid}", fmt.Sprintf("%v", uuid))


	u := c.BaseURL + path

	// Prepare request body
	var reqBody io.Reader
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return result, fmt.Errorf("failed to marshal request body: %w", err)
	}
	reqBody = bytes.NewReader(bodyBytes)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "PUT", u, reqBody)
	if err != nil {
		return result, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	if c.Token != "" {
		req.Header.Set("Authorization", "Bearer "+c.Token)
	}

	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    err,
			Method: "PUT",
			URL:    u,
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return result, &shared.NetworkError{
			Err:    fmt.Errorf("failed to read response: %w", err),
			Method: "PUT",
			URL:    u,
		}
	}

	// Check status code
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return result, shared.ParseAPIError(resp.StatusCode, resp.Status, "PUT", u, respBody)
	}

	// Decode response
	if err := json.Unmarshal(respBody, &result); err != nil {
		return result, &shared.UnmarshalError{
			Err:  err,
			Body: respBody,
			Type: "interface{}",
		}
	}

	return result, nil
}

