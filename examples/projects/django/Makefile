# Django CFG Sample Project - Makefile
#
# Local Development Workflow:
# 1. make install          ‚Üí Install from PyPI (production mode)
# 2. make install-local    ‚Üí Switch to local ~/djangocfg (editable)
# 3. make check-django-cfg ‚Üí Verify which version is active
# 4. make install-prod     ‚Üí Switch back to PyPI
#
# How it works:
# - pyproject.toml always has: django-cfg = {version = "*", extras = ["full"]}
# - install-local uses pip to override PyPI version with local editable install
# - install-prod runs poetry install --sync to restore PyPI version
# - No modifications to pyproject.toml or poetry.lock required!

.PHONY: help install install-local install-prod check-django-cfg env docker test commit kill-ports kill-grpc dev dev-ngrok grpc manage migrate makemigrations shell show-urls check tree config superuser tasks-status tasks-worker api claude populate list-urls check-endpoints

# Python from virtual environment (poetry)
PYTHON := .venv/bin/python
POETRY := poetry
# Path to local django-cfg for development
DJANGO_CFG_LOCAL := $(HOME)/djangocfg

help:
	@echo "Django CFG Sample Project - Make Commands"
	@echo ""
	@echo "Setup & Installation:"
	@echo "  make install          - Install dependencies (PyPI django-cfg)"
	@echo "  make install-local    - Switch to local django-cfg (editable)"
	@echo "  make install-prod     - Switch back to PyPI django-cfg"
	@echo "  make check-django-cfg - Check which django-cfg is installed"
	@echo ""
	@echo "Development:"
	@echo "  make dev           - Run development server (kills port 8000 first)"
	@echo "  make dev-ngrok     - Run development server with ngrok tunnel"
	@echo "  make grpc          - Run gRPC (50051) + ASGI (8000) servers in parallel"
	@echo "  make kill-ports    - Kill processes on port 8000"
	@echo "  make kill-grpc     - Kill ALL manage.py, gRPC, ASGI processes"
	@echo "  make shell         - Open Django shell"
	@echo "  make api           - Generate and deploy API clients (OpenAPI)"
	@echo "  make claude        - Start Claude Code"
	@echo ""
	@echo "Database:"
	@echo "  make migrate       - Run all migrations"
	@echo "  make populate      - Populate database with sample data"
	@echo ""
	@echo "Configuration:"
	@echo "  make config        - Show current configuration"
	@echo "  make check         - Run Django system checks"
	@echo "  make check-settings- Check django-cfg settings"
	@echo ""
	@echo "URLs & Structure:"
	@echo "  make show-urls     - Show all URL patterns"
	@echo "  make list-urls     - List all URLs (Rich formatted)"
	@echo "  make check-endpoints - Check API endpoints status"
	@echo "  make tree          - Show project structure"
	@echo ""
	@echo "Users & Auth:"
	@echo "  make superuser     - Create superuser (interactive)"
	@echo ""
	@echo "Tasks (Dramatiq):"
	@echo "  make tasks-status  - Show task system status"
	@echo "  make tasks-worker  - Run Dramatiq worker"
	@echo "  make tasks-clear   - Clear all pending tasks"
	@echo ""
	@echo "Testing:"
	@echo "  make test          - Run tests"
	@echo ""
	@echo "Utils:"
	@echo "  make manage CMD=<command> - Run manage.py command"
	@echo ""
	@echo "Git:"
	@echo "  make commit        - Quick commit with message"
	@echo ""
	@echo "üìñ Full command reference: see COMMANDS.md"

install:
	@echo "üì¶ Installing dependencies (PyPI django-cfg)..."
	$(POETRY) install
	@echo "‚úÖ Installed django-cfg from PyPI"
	@echo "üí° To use local django-cfg: make install-local"

install-local:
	@echo "üì¶ Switching to local django-cfg..."
	@echo "   Path: $(DJANGO_CFG_LOCAL)"
	@# Check if local django-cfg exists
	@test -d $(DJANGO_CFG_LOCAL) || (echo "‚ùå Error: $(DJANGO_CFG_LOCAL) not found" && exit 1)
	@# Remove lock file to ensure clean state
	@rm -f poetry.lock
	@echo "üîÑ Regenerating poetry.lock..."
	@# Install poetry dependencies (auto-creates new lock file)
	$(POETRY) install
	@# Then install local django-cfg with pip (overwrites PyPI version)
	@echo "üîß Installing local django-cfg (editable mode)..."
	$(POETRY) run pip install -e "$(DJANGO_CFG_LOCAL)[full]"
	@echo ""
	@echo "‚úÖ Local django-cfg installed (editable mode)"
	@echo "üìç Changes in $(DJANGO_CFG_LOCAL) will be immediately reflected"
	@echo "üí° To switch back to PyPI: make install-prod"

install-prod:
	@echo "üì¶ Switching back to PyPI django-cfg..."
	@# Reinstall all poetry dependencies (restores PyPI version)
	@$(POETRY) install --sync
	@echo "‚úÖ PyPI django-cfg restored"
	@echo "üí° To use local version again: make install-local"

check-django-cfg:
	@echo "üîç Checking django-cfg installation..."
	@$(POETRY) run pip show django-cfg | grep -E "^(Name|Version|Location|Editable)" || echo "‚ùå django-cfg not found"
	@echo ""
	@if $(POETRY) run pip show django-cfg | grep -q "Editable project location"; then \
		echo "‚úÖ Using LOCAL django-cfg (editable mode)"; \
	else \
		echo "‚úÖ Using PyPI django-cfg"; \
	fi

env:
	@$(POETRY) env info

docker:
	git pull && python3 devops/manage.py

test:
	$(PYTHON) manage.py test

commit:
	git add . && git commit && git push

kill-ports:
	lsof -i :8000 | awk 'NR>1 {print $$2}' | xargs kill -9 || true

kill-grpc:
	@echo "üî™ Killing all Django manage.py, gRPC and ASGI processes..."
	@# Kill ALL manage.py processes (runserver, rungrpc, shell, etc.)
	@pkill -9 -f "manage.py" 2>/dev/null || true
	@# Kill uvicorn processes
	@pkill -9 -f "uvicorn api.asgi" 2>/dev/null || true
	@# Kill by port (50051 - gRPC)
	@lsof -ti :50051 | xargs kill -9 2>/dev/null || true
	@# Kill by port (8000 - ASGI/Django)
	@lsof -ti :8000 | xargs kill -9 2>/dev/null || true
	@# Kill any Python processes still holding ports
	@lsof -ti :50051 -sTCP:LISTEN | xargs kill -9 2>/dev/null || true
	@lsof -ti :8000 -sTCP:LISTEN | xargs kill -9 2>/dev/null || true
	@# Small delay to ensure ports are released
	@sleep 0.5
	@echo "‚úÖ All Django processes, gRPC and ASGI killed"

dev: kill-ports
	$(PYTHON) manage.py runserver

dev-ngrok: kill-ports
	$(PYTHON) manage.py runserver_ngrok

grpc: kill-grpc
	@echo "üöÄ Starting gRPC server (port 50051) and ASGI server (port 8000) in parallel..."
	@echo ""
	@# Function to handle cleanup on exit (Ctrl+C)
	@bash -c ' \
		trap "echo; echo \"üõë Stopping servers...\"; kill 0; exit" SIGINT SIGTERM; \
		echo "üì° Starting gRPC server on port 50051..."; \
		$(PYTHON) manage.py rungrpc & \
		GRPC_PID=$$!; \
		echo "üåê Starting ASGI server on port 8000 (uvicorn)..."; \
		$(POETRY) run uvicorn api.asgi:application --host 0.0.0.0 --port 8000 --reload & \
		ASGI_PID=$$!; \
		echo ""; \
		echo "‚úÖ Servers started:"; \
		echo "   - gRPC: http://localhost:50051 (PID: $$GRPC_PID)"; \
		echo "   - ASGI: http://localhost:8000 (PID: $$ASGI_PID)"; \
		echo ""; \
		echo "üí° Press Ctrl+C to stop both servers"; \
		echo ""; \
		wait; \
	'

manage:
	$(PYTHON) manage.py $(CMD)

migrate:
	$(PYTHON) manage.py migrate_all

shell:
	$(PYTHON) manage.py shell

show-urls:
	$(PYTHON) manage.py show_urls

list-urls:
	$(PYTHON) manage.py list_urls

check-endpoints:
	$(PYTHON) manage.py check_endpoints

tree:
	$(PYTHON) manage.py tree

config:
	$(PYTHON) manage.py show_config

check:
	$(PYTHON) manage.py check

check-settings:
	$(PYTHON) manage.py check_settings

superuser:
	$(PYTHON) manage.py superuser

tasks-status:
	$(PYTHON) manage.py task_status

tasks-worker:
	$(PYTHON) manage.py rundramatiq

tasks-clear:
	$(PYTHON) manage.py task_clear

# API Generation
api:
	$(PYTHON) manage.py generate_api

# Populate database with sample data
populate:
	rm -f db/*.sqlite3
	$(PYTHON) manage.py migrate_all
	$(PYTHON) manage.py populate_sample_data

# Start Claude Code with dangerously-skip-permissions flag
claude:
	claude --dangerously-skip-permissions
