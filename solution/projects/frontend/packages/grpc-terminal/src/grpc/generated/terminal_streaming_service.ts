// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,long_type_string
// @generated from protobuf file "terminal_streaming_service.proto" (package "terminal", syntax proto3)
// tslint:disable
//
// Terminal Streaming Service - Bidirectional streaming for terminal I/O.
//
// Architecture:
//   Browser (xterm.js) → WebSocket → Django → gRPC → Electron → PTY
//
// Flow:
//   1. Browser opens terminal → Django creates TerminalSession
//   2. Electron connects via gRPC with session_id
//   3. Bidirectional streaming established
//   4. Input: Browser → Django → Electron (stdin)
//   5. Output: Electron → Django → Browser (stdout/stderr)
//
// Version: 1.0.0
// Date: 2025-12-04
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SessionConfig } from "./common";
import { SessionStatus } from "./common";
import { TerminalSize } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";
// ============================================================================
// ELECTRON → DJANGO MESSAGES (via stream)
// ============================================================================

/**
 * Message from Electron to Django
 *
 * @generated from protobuf message terminal.ElectronMessage
 */
export interface ElectronMessage {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string; // Session UUID
    /**
     * @generated from protobuf field: string message_id = 2
     */
    messageId: string; // Unique message ID
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 3
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "register";
        /**
         * Connection lifecycle
         *
         * @generated from protobuf field: terminal.RegisterRequest register = 10
         */
        register: RegisterRequest; // Initial registration
    } | {
        oneofKind: "heartbeat";
        /**
         * @generated from protobuf field: terminal.HeartbeatUpdate heartbeat = 11
         */
        heartbeat: HeartbeatUpdate; // Keepalive
    } | {
        oneofKind: "output";
        /**
         * Terminal output
         *
         * @generated from protobuf field: terminal.TerminalOutput output = 20
         */
        output: TerminalOutput; // PTY stdout/stderr chunk
    } | {
        oneofKind: "commandComplete";
        /**
         * @generated from protobuf field: terminal.CommandComplete command_complete = 21
         */
        commandComplete: CommandComplete; // Command finished
    } | {
        oneofKind: "status";
        /**
         * Status updates
         *
         * @generated from protobuf field: terminal.StatusUpdate status = 30
         */
        status: StatusUpdate; // Session status change
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: terminal.ErrorReport error = 31
         */
        error: ErrorReport; // Error notification
    } | {
        oneofKind: "ack";
        /**
         * Acknowledgements
         *
         * @generated from protobuf field: terminal.CommandAck ack = 40
         */
        ack: CommandAck; // Command acknowledgement
    } | {
        oneofKind: undefined;
    };
}
/**
 * Registration request from Electron
 *
 * @generated from protobuf message terminal.RegisterRequest
 */
export interface RegisterRequest {
    /**
     * @generated from protobuf field: string version = 1
     */
    version: string; // Electron app version
    /**
     * @generated from protobuf field: string hostname = 2
     */
    hostname: string; // Machine hostname
    /**
     * @generated from protobuf field: string platform = 3
     */
    platform: string; // OS platform (darwin, win32, linux)
    /**
     * @generated from protobuf field: repeated string supported_shells = 4
     */
    supportedShells: string[]; // Available shells
    /**
     * @generated from protobuf field: terminal.TerminalSize initial_size = 5
     */
    initialSize?: TerminalSize; // Initial terminal size
}
/**
 * Heartbeat (empty, just for keepalive)
 *
 * @generated from protobuf message terminal.HeartbeatUpdate
 */
export interface HeartbeatUpdate {
}
/**
 * Terminal output chunk (stdout/stderr from PTY)
 *
 * @generated from protobuf message terminal.TerminalOutput
 */
export interface TerminalOutput {
    /**
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array; // Raw output bytes
    /**
     * @generated from protobuf field: bool is_stderr = 2
     */
    isStderr: boolean; // True if from stderr
    /**
     * @generated from protobuf field: int64 sequence = 3
     */
    sequence: string; // Sequence number for ordering
}
/**
 * Command completed notification
 *
 * @generated from protobuf message terminal.CommandComplete
 */
export interface CommandComplete {
    /**
     * @generated from protobuf field: string command_id = 1
     */
    commandId: string; // Command that completed
    /**
     * @generated from protobuf field: int32 exit_code = 2
     */
    exitCode: number; // Exit code
    /**
     * @generated from protobuf field: int64 duration_ms = 3
     */
    durationMs: string; // Execution time in ms
}
/**
 * Status update from Electron
 *
 * @generated from protobuf message terminal.StatusUpdate
 */
export interface StatusUpdate {
    /**
     * @generated from protobuf field: terminal.SessionStatus old_status = 1
     */
    oldStatus: SessionStatus;
    /**
     * @generated from protobuf field: terminal.SessionStatus new_status = 2
     */
    newStatus: SessionStatus;
    /**
     * @generated from protobuf field: string reason = 3
     */
    reason: string; // Reason for status change
    /**
     * @generated from protobuf field: string working_directory = 4
     */
    workingDirectory: string; // Current working directory
}
/**
 * Error report
 *
 * @generated from protobuf message terminal.ErrorReport
 */
export interface ErrorReport {
    /**
     * @generated from protobuf field: string error_code = 1
     */
    errorCode: string; // Error code
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // Error message
    /**
     * @generated from protobuf field: string stack_trace = 3
     */
    stackTrace: string; // Optional stack trace
    /**
     * @generated from protobuf field: bool is_fatal = 4
     */
    isFatal: boolean; // If true, session will close
}
/**
 * Command acknowledgement
 *
 * @generated from protobuf message terminal.CommandAck
 */
export interface CommandAck {
    /**
     * @generated from protobuf field: string command_id = 1
     */
    commandId: string; // ID of acknowledged command
    /**
     * @generated from protobuf field: bool success = 2
     */
    success: boolean; // Successful?
    /**
     * @generated from protobuf field: string message = 3
     */
    message: string; // Optional message
}
// ============================================================================
// DJANGO → ELECTRON MESSAGES (via stream)
// ============================================================================

/**
 * Message from Django to Electron
 *
 * @generated from protobuf message terminal.DjangoMessage
 */
export interface DjangoMessage {
    /**
     * @generated from protobuf field: string command_id = 1
     */
    commandId: string; // Unique command ID
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "input";
        /**
         * Terminal input
         *
         * @generated from protobuf field: terminal.TerminalInput input = 10
         */
        input: TerminalInput; // Keyboard input from browser
    } | {
        oneofKind: "resize";
        /**
         * @generated from protobuf field: terminal.ResizeCommand resize = 11
         */
        resize: ResizeCommand; // Terminal resize
    } | {
        oneofKind: "startSession";
        /**
         * Session control
         *
         * @generated from protobuf field: terminal.StartSessionCommand start_session = 20
         */
        startSession: StartSessionCommand; // Start terminal session
    } | {
        oneofKind: "closeSession";
        /**
         * @generated from protobuf field: terminal.CloseSessionCommand close_session = 21
         */
        closeSession: CloseSessionCommand; // Close terminal session
    } | {
        oneofKind: "signal";
        /**
         * Process control
         *
         * @generated from protobuf field: terminal.SignalCommand signal = 30
         */
        signal: SignalCommand; // Send signal (SIGINT, SIGTERM, etc.)
    } | {
        oneofKind: "cancel";
        /**
         * @generated from protobuf field: terminal.CancelCommand cancel = 31
         */
        cancel: CancelCommand; // Cancel running command
    } | {
        oneofKind: "ping";
        /**
         * Connection management
         *
         * @generated from protobuf field: terminal.PingCommand ping = 40
         */
        ping: PingCommand; // Ping for latency check
    } | {
        oneofKind: "configUpdate";
        /**
         * @generated from protobuf field: terminal.ConfigUpdateCommand config_update = 41
         */
        configUpdate: ConfigUpdateCommand; // Update session config
    } | {
        oneofKind: undefined;
    };
}
/**
 * Terminal input from browser (keyboard, paste)
 *
 * @generated from protobuf message terminal.TerminalInput
 */
export interface TerminalInput {
    /**
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array; // Raw input bytes
    /**
     * @generated from protobuf field: int64 sequence = 2
     */
    sequence: string; // Sequence number
}
/**
 * Terminal resize
 *
 * @generated from protobuf message terminal.ResizeCommand
 */
export interface ResizeCommand {
    /**
     * @generated from protobuf field: terminal.TerminalSize size = 1
     */
    size?: TerminalSize; // New terminal size
}
/**
 * Start terminal session (after registration)
 *
 * @generated from protobuf message terminal.StartSessionCommand
 */
export interface StartSessionCommand {
    /**
     * @generated from protobuf field: terminal.SessionConfig config = 1
     */
    config?: SessionConfig; // Session configuration
}
/**
 * Close terminal session
 *
 * @generated from protobuf message terminal.CloseSessionCommand
 */
export interface CloseSessionCommand {
    /**
     * @generated from protobuf field: string reason = 1
     */
    reason: string; // Reason for closing
    /**
     * @generated from protobuf field: bool force = 2
     */
    force: boolean; // Force close (kill processes)
}
/**
 * Send signal to PTY process
 *
 * @generated from protobuf message terminal.SignalCommand
 */
export interface SignalCommand {
    /**
     * @generated from protobuf field: int32 signal = 1
     */
    signal: number; // Signal number (2=SIGINT, 15=SIGTERM, 9=SIGKILL)
}
/**
 * Cancel running command
 *
 * @generated from protobuf message terminal.CancelCommand
 */
export interface CancelCommand {
    /**
     * @generated from protobuf field: string command_id = 1
     */
    commandId: string; // Command to cancel (if tracking)
}
/**
 * Ping for latency measurement
 *
 * @generated from protobuf message terminal.PingCommand
 */
export interface PingCommand {
    /**
     * @generated from protobuf field: int64 sequence = 1
     */
    sequence: string; // Ping sequence number
}
/**
 * Configuration update
 *
 * @generated from protobuf message terminal.ConfigUpdateCommand
 */
export interface ConfigUpdateCommand {
    /**
     * @generated from protobuf field: terminal.SessionConfig config = 1
     */
    config?: SessionConfig; // New configuration
}
// ============================================================================
// RPC REQUEST/RESPONSE MESSAGES
// ============================================================================

/**
 * Create session
 *
 * @generated from protobuf message terminal.CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string; // User ID (from auth)
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string; // Optional session name
    /**
     * @generated from protobuf field: terminal.SessionConfig config = 3
     */
    config?: SessionConfig; // Initial configuration
}
/**
 * @generated from protobuf message terminal.CreateSessionResponse
 */
export interface CreateSessionResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string session_id = 2
     */
    sessionId: string; // Created session UUID
    /**
     * @generated from protobuf field: string error = 3
     */
    error: string; // Error message if failed
}
/**
 * Close session
 *
 * @generated from protobuf message terminal.CloseSessionRequest
 */
export interface CloseSessionRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string reason = 2
     */
    reason: string;
    /**
     * @generated from protobuf field: bool force = 3
     */
    force: boolean;
}
/**
 * @generated from protobuf message terminal.CloseSessionResponse
 */
export interface CloseSessionResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string error = 2
     */
    error: string;
}
/**
 * Get session status
 *
 * @generated from protobuf message terminal.GetSessionStatusRequest
 */
export interface GetSessionStatusRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
}
/**
 * @generated from protobuf message terminal.GetSessionStatusResponse
 */
export interface GetSessionStatusResponse {
    /**
     * @generated from protobuf field: bool exists = 1
     */
    exists: boolean;
    /**
     * @generated from protobuf field: terminal.SessionStatus status = 2
     */
    status: SessionStatus;
    /**
     * @generated from protobuf field: string electron_hostname = 3
     */
    electronHostname: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp connected_at = 4
     */
    connectedAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_heartbeat_at = 5
     */
    lastHeartbeatAt?: Timestamp;
    /**
     * @generated from protobuf field: int32 commands_count = 6
     */
    commandsCount: number;
}
/**
 * Health check
 *
 * @generated from protobuf message terminal.HealthCheckRequest
 */
export interface HealthCheckRequest {
}
/**
 * @generated from protobuf message terminal.HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * @generated from protobuf field: bool healthy = 1
     */
    healthy: boolean;
    /**
     * @generated from protobuf field: string version = 2
     */
    version: string;
    /**
     * @generated from protobuf field: int32 active_sessions = 3
     */
    activeSessions: number;
    /**
     * @generated from protobuf field: int32 connected_clients = 4
     */
    connectedClients: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class ElectronMessage$Type extends MessageType<ElectronMessage> {
    constructor() {
        super("terminal.ElectronMessage", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 10, name: "register", kind: "message", oneof: "payload", T: () => RegisterRequest },
            { no: 11, name: "heartbeat", kind: "message", oneof: "payload", T: () => HeartbeatUpdate },
            { no: 20, name: "output", kind: "message", oneof: "payload", T: () => TerminalOutput },
            { no: 21, name: "command_complete", kind: "message", oneof: "payload", T: () => CommandComplete },
            { no: 30, name: "status", kind: "message", oneof: "payload", T: () => StatusUpdate },
            { no: 31, name: "error", kind: "message", oneof: "payload", T: () => ErrorReport },
            { no: 40, name: "ack", kind: "message", oneof: "payload", T: () => CommandAck }
        ]);
    }
    create(value?: PartialMessage<ElectronMessage>): ElectronMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.messageId = "";
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ElectronMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ElectronMessage): ElectronMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string message_id */ 2:
                    message.messageId = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 3:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* terminal.RegisterRequest register */ 10:
                    message.payload = {
                        oneofKind: "register",
                        register: RegisterRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).register)
                    };
                    break;
                case /* terminal.HeartbeatUpdate heartbeat */ 11:
                    message.payload = {
                        oneofKind: "heartbeat",
                        heartbeat: HeartbeatUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).heartbeat)
                    };
                    break;
                case /* terminal.TerminalOutput output */ 20:
                    message.payload = {
                        oneofKind: "output",
                        output: TerminalOutput.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).output)
                    };
                    break;
                case /* terminal.CommandComplete command_complete */ 21:
                    message.payload = {
                        oneofKind: "commandComplete",
                        commandComplete: CommandComplete.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).commandComplete)
                    };
                    break;
                case /* terminal.StatusUpdate status */ 30:
                    message.payload = {
                        oneofKind: "status",
                        status: StatusUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).status)
                    };
                    break;
                case /* terminal.ErrorReport error */ 31:
                    message.payload = {
                        oneofKind: "error",
                        error: ErrorReport.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).error)
                    };
                    break;
                case /* terminal.CommandAck ack */ 40:
                    message.payload = {
                        oneofKind: "ack",
                        ack: CommandAck.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).ack)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ElectronMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string message_id = 2; */
        if (message.messageId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.messageId);
        /* google.protobuf.Timestamp timestamp = 3; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* terminal.RegisterRequest register = 10; */
        if (message.payload.oneofKind === "register")
            RegisterRequest.internalBinaryWrite(message.payload.register, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* terminal.HeartbeatUpdate heartbeat = 11; */
        if (message.payload.oneofKind === "heartbeat")
            HeartbeatUpdate.internalBinaryWrite(message.payload.heartbeat, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* terminal.TerminalOutput output = 20; */
        if (message.payload.oneofKind === "output")
            TerminalOutput.internalBinaryWrite(message.payload.output, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* terminal.CommandComplete command_complete = 21; */
        if (message.payload.oneofKind === "commandComplete")
            CommandComplete.internalBinaryWrite(message.payload.commandComplete, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* terminal.StatusUpdate status = 30; */
        if (message.payload.oneofKind === "status")
            StatusUpdate.internalBinaryWrite(message.payload.status, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* terminal.ErrorReport error = 31; */
        if (message.payload.oneofKind === "error")
            ErrorReport.internalBinaryWrite(message.payload.error, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* terminal.CommandAck ack = 40; */
        if (message.payload.oneofKind === "ack")
            CommandAck.internalBinaryWrite(message.payload.ack, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.ElectronMessage
 */
export const ElectronMessage = new ElectronMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterRequest$Type extends MessageType<RegisterRequest> {
    constructor() {
        super("terminal.RegisterRequest", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "platform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "supported_shells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "initial_size", kind: "message", T: () => TerminalSize }
        ]);
    }
    create(value?: PartialMessage<RegisterRequest>): RegisterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.hostname = "";
        message.platform = "";
        message.supportedShells = [];
        if (value !== undefined)
            reflectionMergePartial<RegisterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterRequest): RegisterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* string platform */ 3:
                    message.platform = reader.string();
                    break;
                case /* repeated string supported_shells */ 4:
                    message.supportedShells.push(reader.string());
                    break;
                case /* terminal.TerminalSize initial_size */ 5:
                    message.initialSize = TerminalSize.internalBinaryRead(reader, reader.uint32(), options, message.initialSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string platform = 3; */
        if (message.platform !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.platform);
        /* repeated string supported_shells = 4; */
        for (let i = 0; i < message.supportedShells.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.supportedShells[i]);
        /* terminal.TerminalSize initial_size = 5; */
        if (message.initialSize)
            TerminalSize.internalBinaryWrite(message.initialSize, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.RegisterRequest
 */
export const RegisterRequest = new RegisterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeartbeatUpdate$Type extends MessageType<HeartbeatUpdate> {
    constructor() {
        super("terminal.HeartbeatUpdate", []);
    }
    create(value?: PartialMessage<HeartbeatUpdate>): HeartbeatUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HeartbeatUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeartbeatUpdate): HeartbeatUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeartbeatUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.HeartbeatUpdate
 */
export const HeartbeatUpdate = new HeartbeatUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminalOutput$Type extends MessageType<TerminalOutput> {
    constructor() {
        super("terminal.TerminalOutput", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "is_stderr", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sequence", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<TerminalOutput>): TerminalOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.isStderr = false;
        message.sequence = "0";
        if (value !== undefined)
            reflectionMergePartial<TerminalOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminalOutput): TerminalOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* bool is_stderr */ 2:
                    message.isStderr = reader.bool();
                    break;
                case /* int64 sequence */ 3:
                    message.sequence = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminalOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* bool is_stderr = 2; */
        if (message.isStderr !== false)
            writer.tag(2, WireType.Varint).bool(message.isStderr);
        /* int64 sequence = 3; */
        if (message.sequence !== "0")
            writer.tag(3, WireType.Varint).int64(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.TerminalOutput
 */
export const TerminalOutput = new TerminalOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandComplete$Type extends MessageType<CommandComplete> {
    constructor() {
        super("terminal.CommandComplete", [
            { no: 1, name: "command_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "exit_code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "duration_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<CommandComplete>): CommandComplete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.commandId = "";
        message.exitCode = 0;
        message.durationMs = "0";
        if (value !== undefined)
            reflectionMergePartial<CommandComplete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandComplete): CommandComplete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command_id */ 1:
                    message.commandId = reader.string();
                    break;
                case /* int32 exit_code */ 2:
                    message.exitCode = reader.int32();
                    break;
                case /* int64 duration_ms */ 3:
                    message.durationMs = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandComplete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string command_id = 1; */
        if (message.commandId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.commandId);
        /* int32 exit_code = 2; */
        if (message.exitCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.exitCode);
        /* int64 duration_ms = 3; */
        if (message.durationMs !== "0")
            writer.tag(3, WireType.Varint).int64(message.durationMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.CommandComplete
 */
export const CommandComplete = new CommandComplete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusUpdate$Type extends MessageType<StatusUpdate> {
    constructor() {
        super("terminal.StatusUpdate", [
            { no: 1, name: "old_status", kind: "enum", T: () => ["terminal.SessionStatus", SessionStatus] },
            { no: 2, name: "new_status", kind: "enum", T: () => ["terminal.SessionStatus", SessionStatus] },
            { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "working_directory", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusUpdate>): StatusUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.oldStatus = 0;
        message.newStatus = 0;
        message.reason = "";
        message.workingDirectory = "";
        if (value !== undefined)
            reflectionMergePartial<StatusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusUpdate): StatusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* terminal.SessionStatus old_status */ 1:
                    message.oldStatus = reader.int32();
                    break;
                case /* terminal.SessionStatus new_status */ 2:
                    message.newStatus = reader.int32();
                    break;
                case /* string reason */ 3:
                    message.reason = reader.string();
                    break;
                case /* string working_directory */ 4:
                    message.workingDirectory = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* terminal.SessionStatus old_status = 1; */
        if (message.oldStatus !== 0)
            writer.tag(1, WireType.Varint).int32(message.oldStatus);
        /* terminal.SessionStatus new_status = 2; */
        if (message.newStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.newStatus);
        /* string reason = 3; */
        if (message.reason !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reason);
        /* string working_directory = 4; */
        if (message.workingDirectory !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.workingDirectory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.StatusUpdate
 */
export const StatusUpdate = new StatusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorReport$Type extends MessageType<ErrorReport> {
    constructor() {
        super("terminal.ErrorReport", [
            { no: 1, name: "error_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "stack_trace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_fatal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorReport>): ErrorReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorCode = "";
        message.message = "";
        message.stackTrace = "";
        message.isFatal = false;
        if (value !== undefined)
            reflectionMergePartial<ErrorReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorReport): ErrorReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error_code */ 1:
                    message.errorCode = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* string stack_trace */ 3:
                    message.stackTrace = reader.string();
                    break;
                case /* bool is_fatal */ 4:
                    message.isFatal = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error_code = 1; */
        if (message.errorCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.errorCode);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* string stack_trace = 3; */
        if (message.stackTrace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stackTrace);
        /* bool is_fatal = 4; */
        if (message.isFatal !== false)
            writer.tag(4, WireType.Varint).bool(message.isFatal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.ErrorReport
 */
export const ErrorReport = new ErrorReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandAck$Type extends MessageType<CommandAck> {
    constructor() {
        super("terminal.CommandAck", [
            { no: 1, name: "command_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CommandAck>): CommandAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.commandId = "";
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<CommandAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandAck): CommandAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command_id */ 1:
                    message.commandId = reader.string();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string command_id = 1; */
        if (message.commandId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.commandId);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.CommandAck
 */
export const CommandAck = new CommandAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DjangoMessage$Type extends MessageType<DjangoMessage> {
    constructor() {
        super("terminal.DjangoMessage", [
            { no: 1, name: "command_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 10, name: "input", kind: "message", oneof: "payload", T: () => TerminalInput },
            { no: 11, name: "resize", kind: "message", oneof: "payload", T: () => ResizeCommand },
            { no: 20, name: "start_session", kind: "message", oneof: "payload", T: () => StartSessionCommand },
            { no: 21, name: "close_session", kind: "message", oneof: "payload", T: () => CloseSessionCommand },
            { no: 30, name: "signal", kind: "message", oneof: "payload", T: () => SignalCommand },
            { no: 31, name: "cancel", kind: "message", oneof: "payload", T: () => CancelCommand },
            { no: 40, name: "ping", kind: "message", oneof: "payload", T: () => PingCommand },
            { no: 41, name: "config_update", kind: "message", oneof: "payload", T: () => ConfigUpdateCommand }
        ]);
    }
    create(value?: PartialMessage<DjangoMessage>): DjangoMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.commandId = "";
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<DjangoMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DjangoMessage): DjangoMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command_id */ 1:
                    message.commandId = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 2:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* terminal.TerminalInput input */ 10:
                    message.payload = {
                        oneofKind: "input",
                        input: TerminalInput.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).input)
                    };
                    break;
                case /* terminal.ResizeCommand resize */ 11:
                    message.payload = {
                        oneofKind: "resize",
                        resize: ResizeCommand.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).resize)
                    };
                    break;
                case /* terminal.StartSessionCommand start_session */ 20:
                    message.payload = {
                        oneofKind: "startSession",
                        startSession: StartSessionCommand.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).startSession)
                    };
                    break;
                case /* terminal.CloseSessionCommand close_session */ 21:
                    message.payload = {
                        oneofKind: "closeSession",
                        closeSession: CloseSessionCommand.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).closeSession)
                    };
                    break;
                case /* terminal.SignalCommand signal */ 30:
                    message.payload = {
                        oneofKind: "signal",
                        signal: SignalCommand.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).signal)
                    };
                    break;
                case /* terminal.CancelCommand cancel */ 31:
                    message.payload = {
                        oneofKind: "cancel",
                        cancel: CancelCommand.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).cancel)
                    };
                    break;
                case /* terminal.PingCommand ping */ 40:
                    message.payload = {
                        oneofKind: "ping",
                        ping: PingCommand.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).ping)
                    };
                    break;
                case /* terminal.ConfigUpdateCommand config_update */ 41:
                    message.payload = {
                        oneofKind: "configUpdate",
                        configUpdate: ConfigUpdateCommand.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).configUpdate)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DjangoMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string command_id = 1; */
        if (message.commandId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.commandId);
        /* google.protobuf.Timestamp timestamp = 2; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* terminal.TerminalInput input = 10; */
        if (message.payload.oneofKind === "input")
            TerminalInput.internalBinaryWrite(message.payload.input, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* terminal.ResizeCommand resize = 11; */
        if (message.payload.oneofKind === "resize")
            ResizeCommand.internalBinaryWrite(message.payload.resize, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* terminal.StartSessionCommand start_session = 20; */
        if (message.payload.oneofKind === "startSession")
            StartSessionCommand.internalBinaryWrite(message.payload.startSession, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* terminal.CloseSessionCommand close_session = 21; */
        if (message.payload.oneofKind === "closeSession")
            CloseSessionCommand.internalBinaryWrite(message.payload.closeSession, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* terminal.SignalCommand signal = 30; */
        if (message.payload.oneofKind === "signal")
            SignalCommand.internalBinaryWrite(message.payload.signal, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* terminal.CancelCommand cancel = 31; */
        if (message.payload.oneofKind === "cancel")
            CancelCommand.internalBinaryWrite(message.payload.cancel, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* terminal.PingCommand ping = 40; */
        if (message.payload.oneofKind === "ping")
            PingCommand.internalBinaryWrite(message.payload.ping, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        /* terminal.ConfigUpdateCommand config_update = 41; */
        if (message.payload.oneofKind === "configUpdate")
            ConfigUpdateCommand.internalBinaryWrite(message.payload.configUpdate, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.DjangoMessage
 */
export const DjangoMessage = new DjangoMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminalInput$Type extends MessageType<TerminalInput> {
    constructor() {
        super("terminal.TerminalInput", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sequence", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<TerminalInput>): TerminalInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.sequence = "0";
        if (value !== undefined)
            reflectionMergePartial<TerminalInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminalInput): TerminalInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* int64 sequence */ 2:
                    message.sequence = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminalInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* int64 sequence = 2; */
        if (message.sequence !== "0")
            writer.tag(2, WireType.Varint).int64(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.TerminalInput
 */
export const TerminalInput = new TerminalInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResizeCommand$Type extends MessageType<ResizeCommand> {
    constructor() {
        super("terminal.ResizeCommand", [
            { no: 1, name: "size", kind: "message", T: () => TerminalSize }
        ]);
    }
    create(value?: PartialMessage<ResizeCommand>): ResizeCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResizeCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResizeCommand): ResizeCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* terminal.TerminalSize size */ 1:
                    message.size = TerminalSize.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResizeCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* terminal.TerminalSize size = 1; */
        if (message.size)
            TerminalSize.internalBinaryWrite(message.size, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.ResizeCommand
 */
export const ResizeCommand = new ResizeCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartSessionCommand$Type extends MessageType<StartSessionCommand> {
    constructor() {
        super("terminal.StartSessionCommand", [
            { no: 1, name: "config", kind: "message", T: () => SessionConfig }
        ]);
    }
    create(value?: PartialMessage<StartSessionCommand>): StartSessionCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartSessionCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartSessionCommand): StartSessionCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* terminal.SessionConfig config */ 1:
                    message.config = SessionConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartSessionCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* terminal.SessionConfig config = 1; */
        if (message.config)
            SessionConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.StartSessionCommand
 */
export const StartSessionCommand = new StartSessionCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseSessionCommand$Type extends MessageType<CloseSessionCommand> {
    constructor() {
        super("terminal.CloseSessionCommand", [
            { no: 1, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CloseSessionCommand>): CloseSessionCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = "";
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<CloseSessionCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseSessionCommand): CloseSessionCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reason */ 1:
                    message.reason = reader.string();
                    break;
                case /* bool force */ 2:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseSessionCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reason = 1; */
        if (message.reason !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reason);
        /* bool force = 2; */
        if (message.force !== false)
            writer.tag(2, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.CloseSessionCommand
 */
export const CloseSessionCommand = new CloseSessionCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignalCommand$Type extends MessageType<SignalCommand> {
    constructor() {
        super("terminal.SignalCommand", [
            { no: 1, name: "signal", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SignalCommand>): SignalCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signal = 0;
        if (value !== undefined)
            reflectionMergePartial<SignalCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignalCommand): SignalCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 signal */ 1:
                    message.signal = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignalCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 signal = 1; */
        if (message.signal !== 0)
            writer.tag(1, WireType.Varint).int32(message.signal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.SignalCommand
 */
export const SignalCommand = new SignalCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelCommand$Type extends MessageType<CancelCommand> {
    constructor() {
        super("terminal.CancelCommand", [
            { no: 1, name: "command_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelCommand>): CancelCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.commandId = "";
        if (value !== undefined)
            reflectionMergePartial<CancelCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelCommand): CancelCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command_id */ 1:
                    message.commandId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string command_id = 1; */
        if (message.commandId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.commandId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.CancelCommand
 */
export const CancelCommand = new CancelCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingCommand$Type extends MessageType<PingCommand> {
    constructor() {
        super("terminal.PingCommand", [
            { no: 1, name: "sequence", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<PingCommand>): PingCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sequence = "0";
        if (value !== undefined)
            reflectionMergePartial<PingCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingCommand): PingCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 sequence */ 1:
                    message.sequence = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 sequence = 1; */
        if (message.sequence !== "0")
            writer.tag(1, WireType.Varint).int64(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.PingCommand
 */
export const PingCommand = new PingCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigUpdateCommand$Type extends MessageType<ConfigUpdateCommand> {
    constructor() {
        super("terminal.ConfigUpdateCommand", [
            { no: 1, name: "config", kind: "message", T: () => SessionConfig }
        ]);
    }
    create(value?: PartialMessage<ConfigUpdateCommand>): ConfigUpdateCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConfigUpdateCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigUpdateCommand): ConfigUpdateCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* terminal.SessionConfig config */ 1:
                    message.config = SessionConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigUpdateCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* terminal.SessionConfig config = 1; */
        if (message.config)
            SessionConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.ConfigUpdateCommand
 */
export const ConfigUpdateCommand = new ConfigUpdateCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionRequest$Type extends MessageType<CreateSessionRequest> {
    constructor() {
        super("terminal.CreateSessionRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "config", kind: "message", T: () => SessionConfig }
        ]);
    }
    create(value?: PartialMessage<CreateSessionRequest>): CreateSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionRequest): CreateSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* terminal.SessionConfig config */ 3:
                    message.config = SessionConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* terminal.SessionConfig config = 3; */
        if (message.config)
            SessionConfig.internalBinaryWrite(message.config, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.CreateSessionRequest
 */
export const CreateSessionRequest = new CreateSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionResponse$Type extends MessageType<CreateSessionResponse> {
    constructor() {
        super("terminal.CreateSessionResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateSessionResponse>): CreateSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.sessionId = "";
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionResponse): CreateSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string session_id */ 2:
                    message.sessionId = reader.string();
                    break;
                case /* string error */ 3:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string session_id = 2; */
        if (message.sessionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionId);
        /* string error = 3; */
        if (message.error !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.CreateSessionResponse
 */
export const CreateSessionResponse = new CreateSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseSessionRequest$Type extends MessageType<CloseSessionRequest> {
    constructor() {
        super("terminal.CloseSessionRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CloseSessionRequest>): CloseSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.reason = "";
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<CloseSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseSessionRequest): CloseSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string reason */ 2:
                    message.reason = reader.string();
                    break;
                case /* bool force */ 3:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string reason = 2; */
        if (message.reason !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reason);
        /* bool force = 3; */
        if (message.force !== false)
            writer.tag(3, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.CloseSessionRequest
 */
export const CloseSessionRequest = new CloseSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseSessionResponse$Type extends MessageType<CloseSessionResponse> {
    constructor() {
        super("terminal.CloseSessionResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CloseSessionResponse>): CloseSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<CloseSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseSessionResponse): CloseSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.CloseSessionResponse
 */
export const CloseSessionResponse = new CloseSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSessionStatusRequest$Type extends MessageType<GetSessionStatusRequest> {
    constructor() {
        super("terminal.GetSessionStatusRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSessionStatusRequest>): GetSessionStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSessionStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSessionStatusRequest): GetSessionStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSessionStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.GetSessionStatusRequest
 */
export const GetSessionStatusRequest = new GetSessionStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSessionStatusResponse$Type extends MessageType<GetSessionStatusResponse> {
    constructor() {
        super("terminal.GetSessionStatusResponse", [
            { no: 1, name: "exists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["terminal.SessionStatus", SessionStatus] },
            { no: 3, name: "electron_hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "connected_at", kind: "message", T: () => Timestamp },
            { no: 5, name: "last_heartbeat_at", kind: "message", T: () => Timestamp },
            { no: 6, name: "commands_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetSessionStatusResponse>): GetSessionStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.exists = false;
        message.status = 0;
        message.electronHostname = "";
        message.commandsCount = 0;
        if (value !== undefined)
            reflectionMergePartial<GetSessionStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSessionStatusResponse): GetSessionStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool exists */ 1:
                    message.exists = reader.bool();
                    break;
                case /* terminal.SessionStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* string electron_hostname */ 3:
                    message.electronHostname = reader.string();
                    break;
                case /* google.protobuf.Timestamp connected_at */ 4:
                    message.connectedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.connectedAt);
                    break;
                case /* google.protobuf.Timestamp last_heartbeat_at */ 5:
                    message.lastHeartbeatAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastHeartbeatAt);
                    break;
                case /* int32 commands_count */ 6:
                    message.commandsCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSessionStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool exists = 1; */
        if (message.exists !== false)
            writer.tag(1, WireType.Varint).bool(message.exists);
        /* terminal.SessionStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string electron_hostname = 3; */
        if (message.electronHostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.electronHostname);
        /* google.protobuf.Timestamp connected_at = 4; */
        if (message.connectedAt)
            Timestamp.internalBinaryWrite(message.connectedAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_heartbeat_at = 5; */
        if (message.lastHeartbeatAt)
            Timestamp.internalBinaryWrite(message.lastHeartbeatAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 commands_count = 6; */
        if (message.commandsCount !== 0)
            writer.tag(6, WireType.Varint).int32(message.commandsCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.GetSessionStatusResponse
 */
export const GetSessionStatusResponse = new GetSessionStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckRequest$Type extends MessageType<HealthCheckRequest> {
    constructor() {
        super("terminal.HealthCheckRequest", []);
    }
    create(value?: PartialMessage<HealthCheckRequest>): HealthCheckRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthCheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckRequest): HealthCheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.HealthCheckRequest
 */
export const HealthCheckRequest = new HealthCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckResponse$Type extends MessageType<HealthCheckResponse> {
    constructor() {
        super("terminal.HealthCheckResponse", [
            { no: 1, name: "healthy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "active_sessions", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "connected_clients", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HealthCheckResponse>): HealthCheckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthy = false;
        message.version = "";
        message.activeSessions = 0;
        message.connectedClients = 0;
        if (value !== undefined)
            reflectionMergePartial<HealthCheckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckResponse): HealthCheckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool healthy */ 1:
                    message.healthy = reader.bool();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* int32 active_sessions */ 3:
                    message.activeSessions = reader.int32();
                    break;
                case /* int32 connected_clients */ 4:
                    message.connectedClients = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool healthy = 1; */
        if (message.healthy !== false)
            writer.tag(1, WireType.Varint).bool(message.healthy);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* int32 active_sessions = 3; */
        if (message.activeSessions !== 0)
            writer.tag(3, WireType.Varint).int32(message.activeSessions);
        /* int32 connected_clients = 4; */
        if (message.connectedClients !== 0)
            writer.tag(4, WireType.Varint).int32(message.connectedClients);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message terminal.HealthCheckResponse
 */
export const HealthCheckResponse = new HealthCheckResponse$Type();
/**
 * @generated ServiceType for protobuf service terminal.TerminalStreamingService
 */
export const TerminalStreamingService = new ServiceType("terminal.TerminalStreamingService", [
    { name: "ConnectTerminal", serverStreaming: true, clientStreaming: true, options: {}, I: ElectronMessage, O: DjangoMessage },
    { name: "CreateSession", options: {}, I: CreateSessionRequest, O: CreateSessionResponse },
    { name: "CloseSession", options: {}, I: CloseSessionRequest, O: CloseSessionResponse },
    { name: "GetSessionStatus", options: {}, I: GetSessionStatusRequest, O: GetSessionStatusResponse },
    { name: "HealthCheck", options: {}, I: HealthCheckRequest, O: HealthCheckResponse }
]);
