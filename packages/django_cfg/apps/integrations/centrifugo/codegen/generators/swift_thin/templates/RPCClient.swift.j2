// CentrifugoRPCClient.swift
// Centrifugo RPC Client using SwiftCentrifuge
// Auto-generated - DO NOT EDIT

import Foundation
import SwiftCentrifuge

// MARK: - RPC Error Types

/// RPC error type.
public enum RPCError: Error, LocalizedError {
    case notConnected
    case timeout
    case serverError(code: Int, message: String)
    case encodingError(Error)
    case decodingError(Error)
    case webSocketError(Error)
    case connectionFailed(String)

    public var errorDescription: String? {
        switch self {
        case .notConnected:
            return "Not connected to Centrifugo server"
        case .timeout:
            return "RPC request timed out"
        case .serverError(let code, let message):
            return "Server error (\(code)): \(message)"
        case .encodingError(let error):
            return "Failed to encode request: \(error.localizedDescription)"
        case .decodingError(let error):
            return "Failed to decode response: \(error.localizedDescription)"
        case .webSocketError(let error):
            return "WebSocket error: \(error.localizedDescription)"
        case .connectionFailed(let reason):
            return "Connection failed: \(reason)"
        }
    }
}

// MARK: - Connection State

/// Centrifugo connection state.
public enum CentrifugoConnectionState: Sendable {
    case disconnected
    case connecting
    case connected
}

// MARK: - RPC Client Delegate

/// Internal delegate to capture connection events.
private class RPCClientDelegate: CentrifugeClientDelegate {
    var onConnectedHandler: ((CentrifugeConnectedEvent) -> Void)?
    var onDisconnectedHandler: ((CentrifugeDisconnectedEvent) -> Void)?
    var onConnectingHandler: ((CentrifugeConnectingEvent) -> Void)?
    var onErrorHandler: ((CentrifugeErrorEvent) -> Void)?

    func onConnected(_ client: CentrifugeClient, _ event: CentrifugeConnectedEvent) {
        onConnectedHandler?(event)
    }

    func onDisconnected(_ client: CentrifugeClient, _ event: CentrifugeDisconnectedEvent) {
        onDisconnectedHandler?(event)
    }

    func onConnecting(_ client: CentrifugeClient, _ event: CentrifugeConnectingEvent) {
        onConnectingHandler?(event)
    }

    func onError(_ client: CentrifugeClient, _ event: CentrifugeErrorEvent) {
        onErrorHandler?(event)
    }

    // Server-side subscription events (optional)
    func onSubscribed(_ client: CentrifugeClient, _ event: CentrifugeServerSubscribedEvent) {}
    func onSubscribing(_ client: CentrifugeClient, _ event: CentrifugeServerSubscribingEvent) {}
    func onUnsubscribed(_ client: CentrifugeClient, _ event: CentrifugeServerUnsubscribedEvent) {}
    func onPublication(_ client: CentrifugeClient, _ event: CentrifugeServerPublicationEvent) {}
    func onJoin(_ client: CentrifugeClient, _ event: CentrifugeServerJoinEvent) {}
    func onLeave(_ client: CentrifugeClient, _ event: CentrifugeServerLeaveEvent) {}
}

// MARK: - Centrifugo RPC Client

/// Async RPC client for Centrifugo using SwiftCentrifuge library.
///
/// Usage:
/// ```swift
/// let client = try CentrifugoRPCClient(
///     url: "ws://127.0.0.1:8120/connection/websocket",
///     token: "jwt-token",
///     userId: "user-123"
/// )
/// try await client.connect()
/// let result: MyResult = try await client.call(method: "my.method", params: MyParams(...))
/// await client.disconnect()
/// ```
public actor CentrifugoRPCClient {
    // MARK: - Properties

    private let url: String
    private let token: String
    private let userId: String
    private let timeout: TimeInterval
    private var client: CentrifugeClient?
    private let delegate: RPCClientDelegate

    /// Current connection state.
    public private(set) var state: CentrifugoConnectionState = .disconnected

    // Connection continuations for async/await
    private var connectionContinuation: CheckedContinuation<Void, Error>?

    // MARK: - Initialization

    /// Create a new Centrifugo RPC client.
    ///
    /// - Parameters:
    ///   - url: WebSocket URL of the Centrifugo server
    ///   - token: JWT authentication token
    ///   - userId: User ID for logging/debugging
    ///   - timeout: RPC call timeout in seconds (default: 30)
    public init(
        url: String,
        token: String,
        userId: String,
        timeout: TimeInterval = 30
    ) throws {
        self.url = url
        self.token = token
        self.userId = userId
        self.timeout = timeout
        self.delegate = RPCClientDelegate()
    }

    // MARK: - Connection Management

    /// Connect to the Centrifugo server.
    ///
    /// Establishes WebSocket connection and authenticates with JWT token.
    /// - Throws: RPCError if connection fails
    public func connect() async throws {
        guard state == .disconnected else { return }

        state = .connecting

        // Configure client
        let config = CentrifugeClientConfig(
            token: token,
            useNativeWebSocket: true  // Use URLSessionWebSocketTask
        )

        client = CentrifugeClient(endpoint: url, config: config, delegate: delegate)

        // Set up delegate handlers
        setupDelegateHandlers()

        // Wait for connection
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            connectionContinuation = continuation
            client?.connect()

            // Timeout
            Task {
                try? await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
                if state == .connecting {
                    connectionContinuation?.resume(throwing: RPCError.timeout)
                    connectionContinuation = nil
                }
            }
        }
    }

    /// Set up delegate handlers for connection events.
    private func setupDelegateHandlers() {
        delegate.onConnectedHandler = { [weak self] event in
            guard let self = self else { return }
            Task {
                await self.handleConnected(event)
            }
        }

        delegate.onDisconnectedHandler = { [weak self] event in
            guard let self = self else { return }
            Task {
                await self.handleDisconnected(event)
            }
        }

        delegate.onErrorHandler = { [weak self] event in
            guard let self = self else { return }
            Task {
                await self.handleError(event)
            }
        }
    }

    private func handleConnected(_ event: CentrifugeConnectedEvent) {
        state = .connected
        connectionContinuation?.resume(returning: ())
        connectionContinuation = nil
    }

    private func handleDisconnected(_ event: CentrifugeDisconnectedEvent) {
        state = .disconnected
        if let continuation = connectionContinuation {
            continuation.resume(throwing: RPCError.connectionFailed("Disconnected: \(event.reason)"))
            connectionContinuation = nil
        }
    }

    private func handleError(_ event: CentrifugeErrorEvent) {
        if let continuation = connectionContinuation {
            continuation.resume(throwing: RPCError.webSocketError(event.error))
            connectionContinuation = nil
        }
    }

    /// Disconnect from the Centrifugo server.
    public func disconnect() async {
        client?.disconnect()
        client = nil
        state = .disconnected
    }

    // MARK: - Subscriptions

    private var subscriptions: [String: CentrifugeSubscription] = [:]

    /// Subscribe to a channel for real-time events.
    ///
    /// - Parameters:
    ///   - channel: Channel name to subscribe to
    ///   - onPublication: Callback for incoming messages (raw Data)
    /// - Throws: RPCError if subscription fails
    public func subscribe(
        channel: String,
        onPublication: @escaping @Sendable (Data) -> Void
    ) async throws {
        guard state == .connected, let client = client else {
            throw RPCError.notConnected
        }

        // Create subscription
        let sub = client.newSubscription(channel)

        // Set up publication handler
        sub.on(event: .publication) { event in
            onPublication(event.data)
        }

        sub.on(event: .subscribed) { _ in
            // Subscription confirmed
        }

        sub.on(event: .error) { event in
            // Log error but don't throw
        }

        // Store and subscribe
        subscriptions[channel] = sub
        try await sub.subscribe()
    }

    /// Unsubscribe from a channel.
    ///
    /// - Parameter channel: Channel name to unsubscribe from
    public func unsubscribe(channel: String) async throws {
        guard let sub = subscriptions[channel] else { return }
        try await sub.unsubscribe()
        subscriptions.removeValue(forKey: channel)
    }

    /// Unsubscribe from all channels.
    public func unsubscribeAll() async {
        for (_, sub) in subscriptions {
            try? await sub.unsubscribe()
        }
        subscriptions.removeAll()
    }

    // MARK: - RPC Methods

    /// Call an RPC method and wait for response.
    ///
    /// - Parameters:
    ///   - method: RPC method name (e.g., "file.list_directory")
    ///   - params: Request parameters (must be Encodable)
    /// - Returns: Response decoded as the specified type
    /// - Throws: RPCError if the call fails
    public func call<P: Encodable, R: Decodable>(
        method: String,
        params: P
    ) async throws -> R {
        guard state == .connected, let client = client else {
            throw RPCError.notConnected
        }

        // Encode params to JSON
        let encoder = JSONEncoder()
        let paramsData: Data
        do {
            paramsData = try encoder.encode(params)
        } catch {
            throw RPCError.encodingError(error)
        }

        // Make RPC call
        return try await withCheckedThrowingContinuation { continuation in
            client.rpc(method: method, data: paramsData) { result in
                switch result {
                case .success(let rpcResult):
                    // Decode response
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(R.self, from: rpcResult.data)
                        continuation.resume(returning: decoded)
                    } catch {
                        continuation.resume(throwing: RPCError.decodingError(error))
                    }
                case .failure(let error):
                    continuation.resume(throwing: RPCError.webSocketError(error))
                }
            }
        }
    }

    /// Send a fire-and-forget RPC message (no response expected).
    ///
    /// - Parameters:
    ///   - method: RPC method name
    ///   - params: Request parameters
    /// - Throws: RPCError if sending fails
    public func send<P: Encodable>(method: String, params: P) async throws {
        guard state == .connected, let client = client else {
            throw RPCError.notConnected
        }

        // Encode params
        let encoder = JSONEncoder()
        let paramsData: Data
        do {
            paramsData = try encoder.encode(params)
        } catch {
            throw RPCError.encodingError(error)
        }

        // Send without waiting for response
        client.rpc(method: method, data: paramsData) { _ in
            // Ignore result for fire-and-forget
        }
    }
}

// MARK: - Convenience Extensions

extension CentrifugoRPCClient {
    /// Check if connected to the server.
    public var isConnected: Bool {
        state == .connected
    }
}
