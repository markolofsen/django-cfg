---
title: Currency Examples
description: Real-world examples and use cases for Django-CFG Currency Module
sidebar_label: Examples
sidebar_position: 4
---

# Real-World Examples

Practical examples showing how to use the Django-CFG Currency Module in real applications.

## 🛒 E-commerce Applications

### Multi-Currency Product Catalog

```python
from django.db import models
from django_cfg.modules.django_currency import convert_currency

class Product(models.Model):
    name = models.CharField(max_length=200)
    base_price = models.DecimalField(max_digits=10, decimal_places=2)
    base_currency = models.CharField(max_length=3, default='USD')
    
    def get_localized_price(self, user_currency):
        """Get product price in user's preferred currency."""
        if self.base_currency == user_currency:
            return {
                'amount': float(self.base_price),
                'currency': user_currency,
                'is_converted': False
            }
        
        try:
            converted_amount = convert_currency(
                float(self.base_price),
                self.base_currency,
                user_currency
            )
            return {
                'amount': round(converted_amount, 2),
                'currency': user_currency,
                'is_converted': True,
                'original_amount': float(self.base_price),
                'original_currency': self.base_currency
            }
        except Exception as e:
            # Fallback to base currency if conversion fails
            return {
                'amount': float(self.base_price),
                'currency': self.base_currency,
                'is_converted': False,
                'error': str(e)
            }

# Usage in views
def product_detail(request, product_id):
    product = Product.objects.get(id=product_id)
    user_currency = request.session.get('currency', 'USD')
    
    price_info = product.get_localized_price(user_currency)
    
    return render(request, 'product_detail.html', {
        'product': product,
        'price': price_info
    })
```

### Shopping Cart with Multi-Currency Support

```python
from django_cfg.modules.django_currency import CurrencyConverter

class ShoppingCart:
    def __init__(self, user_currency='USD'):
        self.items = []
        self.user_currency = user_currency
        self.converter = CurrencyConverter()
    
    def add_item(self, product, quantity, price_currency='USD'):
        """Add item to cart with automatic currency conversion."""
        item = {
            'product': product,
            'quantity': quantity,
            'original_price': product.base_price,
            'original_currency': price_currency,
            'user_currency': self.user_currency
        }
        
        # Convert price to user currency
        if price_currency != self.user_currency:
            converted_price = convert_currency(
                float(product.base_price),
                price_currency,
                self.user_currency
            )
            item['converted_price'] = converted_price
        else:
            item['converted_price'] = float(product.base_price)
        
        item['total_price'] = item['converted_price'] * quantity
        self.items.append(item)
    
    def get_cart_total(self):
        """Calculate total cart value in user currency."""
        total = sum(item['total_price'] for item in self.items)
        
        return {
            'total': round(total, 2),
            'currency': self.user_currency,
            'item_count': len(self.items),
            'items': self.items
        }
    
    def change_currency(self, new_currency):
        """Change cart currency and recalculate all prices."""
        old_currency = self.user_currency
        self.user_currency = new_currency
        
        for item in self.items:
            # Convert from old user currency to new currency
            new_price = convert_currency(
                item['converted_price'],
                old_currency,
                new_currency
            )
            item['converted_price'] = new_price
            item['total_price'] = new_price * item['quantity']
            item['user_currency'] = new_currency

# Usage example
cart = ShoppingCart(user_currency='EUR')
cart.add_item(product, quantity=2, price_currency='USD')
cart_summary = cart.get_cart_total()
```

## 💰 Financial Applications

### Portfolio Tracker

```python
from django_cfg.modules.django_currency import CurrencyConverter
from datetime import datetime

class CryptoPortfolio:
    def __init__(self, base_currency='USD'):
        self.holdings = {}
        self.base_currency = base_currency
        self.converter = CurrencyConverter()
    
    def add_holding(self, crypto_symbol, amount, purchase_price_usd=None):
        """Add cryptocurrency holding to portfolio."""
        self.holdings[crypto_symbol] = {
            'amount': amount,
            'purchase_price_usd': purchase_price_usd,
            'added_at': datetime.now()
        }
    
    def get_current_value(self):
        """Get current portfolio value in base currency."""
        total_value = 0
        holding_details = []
        
        for crypto, data in self.holdings.items():
            try:
                # Get current price in base currency
                current_price = convert_currency(
                    1, crypto, self.base_currency
                )
                
                # Calculate holding value
                holding_value = data['amount'] * current_price
                total_value += holding_value
                
                # Calculate P&L if purchase price available
                pnl = None
                pnl_percentage = None
                if data['purchase_price_usd']:
                    purchase_value_base = convert_currency(
                        data['amount'] * data['purchase_price_usd'],
                        'USD',
                        self.base_currency
                    )
                    pnl = holding_value - purchase_value_base
                    pnl_percentage = (pnl / purchase_value_base) * 100
                
                holding_details.append({
                    'crypto': crypto,
                    'amount': data['amount'],
                    'current_price': current_price,
                    'current_value': holding_value,
                    'purchase_price_usd': data['purchase_price_usd'],
                    'pnl': pnl,
                    'pnl_percentage': pnl_percentage,
                    'currency': self.base_currency
                })
                
            except Exception as e:
                print(f"Error calculating value for {crypto}: {e}")
        
        return {
            'total_value': round(total_value, 2),
            'currency': self.base_currency,
            'holdings': holding_details,
            'updated_at': datetime.now()
        }
    
    def get_allocation(self):
        """Get portfolio allocation percentages."""
        portfolio_data = self.get_current_value()
        total_value = portfolio_data['total_value']
        
        allocations = []
        for holding in portfolio_data['holdings']:
            percentage = (holding['current_value'] / total_value) * 100
            allocations.append({
                'crypto': holding['crypto'],
                'value': holding['current_value'],
                'percentage': round(percentage, 2)
            })
        
        return sorted(allocations, key=lambda x: x['percentage'], reverse=True)

# Usage example
portfolio = CryptoPortfolio(base_currency='EUR')
portfolio.add_holding('BTC', 0.5, purchase_price_usd=45000)
portfolio.add_holding('ETH', 2.0, purchase_price_usd=3000)
portfolio.add_holding('ADA', 1000, purchase_price_usd=1.2)

current_value = portfolio.get_current_value()
allocations = portfolio.get_allocation()
```

### Investment Returns Calculator

```python
from django_cfg.modules.django_currency import convert_currency
from datetime import datetime, timedelta

class InvestmentCalculator:
    @staticmethod
    def calculate_returns(
        initial_amount, 
        initial_currency,
        current_amount, 
        current_currency,
        investment_date,
        base_currency='USD'
    ):
        """Calculate investment returns in base currency."""
        
        # Convert both amounts to base currency for comparison
        initial_base = convert_currency(
            initial_amount, 
            initial_currency, 
            base_currency
        )
        
        current_base = convert_currency(
            current_amount, 
            current_currency, 
            base_currency
        )
        
        # Calculate returns
        absolute_return = current_base - initial_base
        percentage_return = (absolute_return / initial_base) * 100
        
        # Calculate time-based metrics
        days_invested = (datetime.now() - investment_date).days
        years_invested = days_invested / 365.25
        
        # Annualized return
        if years_invested > 0:
            annualized_return = ((current_base / initial_base) ** (1 / years_invested) - 1) * 100
        else:
            annualized_return = 0
        
        return {
            'initial_amount': initial_amount,
            'initial_currency': initial_currency,
            'initial_base_value': round(initial_base, 2),
            'current_amount': current_amount,
            'current_currency': current_currency,
            'current_base_value': round(current_base, 2),
            'base_currency': base_currency,
            'absolute_return': round(absolute_return, 2),
            'percentage_return': round(percentage_return, 2),
            'annualized_return': round(annualized_return, 2),
            'days_invested': days_invested,
            'years_invested': round(years_invested, 2)
        }

# Usage example
calculator = InvestmentCalculator()

# Bitcoin investment analysis
btc_investment = calculator.calculate_returns(
    initial_amount=10000,  # $10,000 USD
    initial_currency='USD',
    current_amount=0.3,    # 0.3 BTC
    current_currency='BTC',
    investment_date=datetime(2023, 1, 1),
    base_currency='USD'
)

print(f"Investment Return: {btc_investment['percentage_return']:.2f}%")
print(f"Annualized Return: {btc_investment['annualized_return']:.2f}%")
```

## 🚗 Import/Export Business

### Vehicle Import Cost Calculator

```python
from django_cfg.modules.django_currency import convert_currency

class VehicleImportCalculator:
    def __init__(self):
        # Tax rates by country
        self.tax_rates = {
            'RU': {
                'low': 0.54,     # <200k RUB
                'medium': 0.48,  # 200k-450k RUB  
                'high': 0.54     # >450k RUB
            },
            'US': {
                'standard': 0.025,  # 2.5% standard
                'luxury': 0.1       # 10% luxury (>100k USD)
            },
            'EU': {
                'standard': 0.1,    # 10% standard
                'vat': 0.19         # 19% VAT
            }
        }
    
    def calculate_import_cost(
        self, 
        vehicle_price, 
        price_currency, 
        target_country,
        vehicle_age=0,
        engine_volume=2.0
    ):
        """Calculate total import cost including taxes and duties."""
        
        # Get local currency for target country
        local_currencies = {
            'RU': 'RUB',
            'US': 'USD', 
            'EU': 'EUR'
        }
        local_currency = local_currencies[target_country]
        
        # Convert vehicle price to local currency
        local_price = convert_currency(
            vehicle_price, 
            price_currency, 
            local_currency
        )
        
        # Calculate taxes based on country
        if target_country == 'RU':
            return self._calculate_russian_import(
                local_price, vehicle_age, engine_volume
            )
        elif target_country == 'US':
            return self._calculate_us_import(local_price)
        elif target_country == 'EU':
            return self._calculate_eu_import(local_price)
    
    def _calculate_russian_import(self, price_rub, age, engine_volume):
        """Calculate Russian import taxes."""
        # Age-based duty rates
        if age <= 3:
            if price_rub <= 200000:
                duty_rate = 0.54
            elif price_rub <= 450000:
                duty_rate = 0.48
            else:
                duty_rate = 0.54
        else:
            # Older cars - engine volume based
            if engine_volume <= 1.0:
                duty_rate = 1.5
            elif engine_volume <= 1.5:
                duty_rate = 1.7
            elif engine_volume <= 2.5:
                duty_rate = 2.5
            else:
                duty_rate = 3.0
        
        duty_amount = price_rub * duty_rate
        total_cost = price_rub + duty_amount
        
        return {
            'vehicle_price': round(price_rub, 2),
            'currency': 'RUB',
            'duty_rate': duty_rate,
            'duty_amount': round(duty_amount, 2),
            'total_cost': round(total_cost, 2),
            'country': 'Russia'
        }
    
    def _calculate_us_import(self, price_usd):
        """Calculate US import taxes."""
        # Determine if luxury vehicle
        is_luxury = price_usd > 100000
        duty_rate = self.tax_rates['US']['luxury'] if is_luxury else self.tax_rates['US']['standard']
        
        duty_amount = price_usd * duty_rate
        total_cost = price_usd + duty_amount
        
        return {
            'vehicle_price': round(price_usd, 2),
            'currency': 'USD',
            'duty_rate': duty_rate,
            'duty_amount': round(duty_amount, 2),
            'total_cost': round(total_cost, 2),
            'is_luxury': is_luxury,
            'country': 'United States'
        }
    
    def _calculate_eu_import(self, price_eur):
        """Calculate EU import taxes."""
        import_duty = price_eur * self.tax_rates['EU']['standard']
        price_with_duty = price_eur + import_duty
        vat_amount = price_with_duty * self.tax_rates['EU']['vat']
        total_cost = price_with_duty + vat_amount
        
        return {
            'vehicle_price': round(price_eur, 2),
            'currency': 'EUR',
            'import_duty': round(import_duty, 2),
            'vat_amount': round(vat_amount, 2),
            'total_cost': round(total_cost, 2),
            'country': 'European Union'
        }

# Usage example
calculator = VehicleImportCalculator()

# Korean car import to Russia
korean_car_cost = calculator.calculate_import_cost(
    vehicle_price=25000000,  # 25M KRW
    price_currency='KRW',
    target_country='RU',
    vehicle_age=2,
    engine_volume=2.5
)

print(f"Total import cost: {korean_car_cost['total_cost']} {korean_car_cost['currency']}")
```

### Global Pricing Calculator

```python
from django_cfg.modules.django_currency import CurrencyConverter

class GlobalPricingService:
    def __init__(self):
        self.converter = CurrencyConverter()
        self.regional_multipliers = {
            'US': 1.0,      # Base pricing
            'EU': 1.15,     # Higher taxes
            'CA': 1.05,     # Slight increase
            'AU': 1.20,     # Higher costs
            'JP': 0.95,     # Competitive market
            'IN': 0.70      # Price sensitivity
        }
    
    def calculate_regional_pricing(self, base_price_usd, target_regions=None):
        """Calculate optimal pricing for different regions."""
        if target_regions is None:
            target_regions = list(self.regional_multipliers.keys())
        
        regional_currencies = {
            'US': 'USD',
            'EU': 'EUR', 
            'CA': 'CAD',
            'AU': 'AUD',
            'JP': 'JPY',
            'IN': 'INR'
        }
        
        pricing_data = []
        
        for region in target_regions:
            if region not in self.regional_multipliers:
                continue
            
            # Apply regional multiplier
            adjusted_price_usd = base_price_usd * self.regional_multipliers[region]
            
            # Convert to local currency
            local_currency = regional_currencies[region]
            local_price = convert_currency(
                adjusted_price_usd, 
                'USD', 
                local_currency
            )
            
            pricing_data.append({
                'region': region,
                'currency': local_currency,
                'base_price_usd': base_price_usd,
                'adjusted_price_usd': round(adjusted_price_usd, 2),
                'local_price': round(local_price, 2),
                'multiplier': self.regional_multipliers[region]
            })
        
        return pricing_data
    
    def get_pricing_comparison(self, base_price_usd):
        """Get pricing comparison across all regions."""
        pricing_data = self.calculate_regional_pricing(base_price_usd)
        
        # Convert all to USD for comparison
        usd_prices = []
        for item in pricing_data:
            usd_equivalent = convert_currency(
                item['local_price'],
                item['currency'],
                'USD'
            )
            item['usd_equivalent'] = round(usd_equivalent, 2)
            usd_prices.append(usd_equivalent)
        
        # Calculate statistics
        min_price = min(usd_prices)
        max_price = max(usd_prices)
        avg_price = sum(usd_prices) / len(usd_prices)
        
        return {
            'base_price': base_price_usd,
            'regional_pricing': pricing_data,
            'statistics': {
                'min_price_usd': round(min_price, 2),
                'max_price_usd': round(max_price, 2),
                'avg_price_usd': round(avg_price, 2),
                'price_range_percentage': round(((max_price - min_price) / min_price) * 100, 2)
            }
        }

# Usage example
pricing_service = GlobalPricingService()

# Software subscription pricing
subscription_pricing = pricing_service.get_pricing_comparison(99.0)  # $99 USD base

for region_data in subscription_pricing['regional_pricing']:
    print(f"{region_data['region']}: {region_data['local_price']} {region_data['currency']} "
          f"(${region_data['usd_equivalent']} USD equivalent)")
```

## 🎮 Gaming & Entertainment

### In-Game Currency Exchange

```python
from django_cfg.modules.django_currency import convert_currency

class GameCurrencyService:
    def __init__(self):
        # In-game currency exchange rates (gems to real currency)
        self.gem_rates_usd = {
            100: 0.99,    # $0.99 for 100 gems
            500: 4.99,    # $4.99 for 500 gems  
            1000: 9.99,   # $9.99 for 1000 gems
            2500: 19.99,  # $19.99 for 2500 gems
            5000: 39.99   # $39.99 for 5000 gems
        }
    
    def get_gem_packages_in_currency(self, user_currency='USD'):
        """Get gem packages converted to user's currency."""
        packages = []
        
        for gems, price_usd in self.gem_rates_usd.items():
            if user_currency == 'USD':
                local_price = price_usd
            else:
                local_price = convert_currency(price_usd, 'USD', user_currency)
            
            # Calculate value metrics
            gems_per_dollar = gems / price_usd
            local_price_per_gem = local_price / gems
            
            packages.append({
                'gems': gems,
                'price': round(local_price, 2),
                'currency': user_currency,
                'original_price_usd': price_usd,
                'gems_per_dollar': round(gems_per_dollar, 2),
                'price_per_gem': round(local_price_per_gem, 4),
                'bonus_percentage': self._calculate_bonus(gems)
            })
        
        return sorted(packages, key=lambda x: x['gems'])
    
    def _calculate_bonus(self, gems):
        """Calculate bonus percentage compared to smallest package."""
        base_rate = self.gem_rates_usd[100] / 100  # Price per gem for smallest package
        current_rate = self.gem_rates_usd[gems] / gems
        savings = (base_rate - current_rate) / base_rate * 100
        return round(max(0, savings), 1)
    
    def calculate_optimal_purchase(self, desired_gems, user_currency='USD'):
        """Find the most cost-effective way to buy desired gems."""
        packages = self.get_gem_packages_in_currency(user_currency)
        
        # Simple greedy approach - can be optimized with dynamic programming
        remaining_gems = desired_gems
        purchases = []
        total_cost = 0
        total_gems = 0
        
        # Sort packages by value (gems per currency unit) descending
        packages.sort(key=lambda x: x['gems'] / x['price'], reverse=True)
        
        for package in packages:
            while remaining_gems >= package['gems']:
                purchases.append(package)
                total_cost += package['price']
                total_gems += package['gems']
                remaining_gems -= package['gems']
        
        # Handle remaining gems with smallest package
        if remaining_gems > 0:
            smallest_package = min(packages, key=lambda x: x['gems'])
            purchases.append(smallest_package)
            total_cost += smallest_package['price']
            total_gems += smallest_package['gems']
        
        return {
            'desired_gems': desired_gems,
            'total_gems_received': total_gems,
            'bonus_gems': total_gems - desired_gems,
            'total_cost': round(total_cost, 2),
            'currency': user_currency,
            'packages_to_buy': purchases,
            'average_cost_per_gem': round(total_cost / total_gems, 4)
        }

# Usage example
game_currency = GameCurrencyService()

# Get packages for European player
eu_packages = game_currency.get_gem_packages_in_currency('EUR')

# Find optimal purchase for 3000 gems
optimal_purchase = game_currency.calculate_optimal_purchase(3000, 'EUR')
```

## Business Intelligence

### Multi-Currency Revenue Dashboard

```python
from django_cfg.modules.django_currency import convert_currency
from datetime import datetime, timedelta

class RevenueAnalytics:
    def __init__(self, base_currency='USD'):
        self.base_currency = base_currency
    
    def normalize_revenue_data(self, revenue_records):
        """Convert all revenue records to base currency."""
        normalized_records = []
        
        for record in revenue_records:
            # Convert to base currency if needed
            if record['currency'] != self.base_currency:
                base_amount = convert_currency(
                    record['amount'],
                    record['currency'],
                    self.base_currency
                )
            else:
                base_amount = record['amount']
            
            normalized_record = {
                **record,
                'base_amount': round(base_amount, 2),
                'base_currency': self.base_currency,
                'exchange_rate': base_amount / record['amount'] if record['amount'] > 0 else 0
            }
            normalized_records.append(normalized_record)
        
        return normalized_records
    
    def calculate_revenue_metrics(self, revenue_records, period_days=30):
        """Calculate revenue metrics in base currency."""
        normalized_data = self.normalize_revenue_data(revenue_records)
        
        # Filter by period
        cutoff_date = datetime.now() - timedelta(days=period_days)
        recent_records = [
            r for r in normalized_data 
            if r['date'] >= cutoff_date
        ]
        
        # Calculate metrics
        total_revenue = sum(r['base_amount'] for r in recent_records)
        avg_transaction = total_revenue / len(recent_records) if recent_records else 0
        
        # Revenue by original currency
        currency_breakdown = {}
        for record in recent_records:
            currency = record['currency']
            if currency not in currency_breakdown:
                currency_breakdown[currency] = {
                    'original_amount': 0,
                    'base_amount': 0,
                    'transaction_count': 0
                }
            
            currency_breakdown[currency]['original_amount'] += record['amount']
            currency_breakdown[currency]['base_amount'] += record['base_amount']
            currency_breakdown[currency]['transaction_count'] += 1
        
        # Calculate percentages
        for currency_data in currency_breakdown.values():
            currency_data['percentage'] = round(
                (currency_data['base_amount'] / total_revenue) * 100, 2
            ) if total_revenue > 0 else 0
        
        return {
            'period_days': period_days,
            'base_currency': self.base_currency,
            'total_revenue': round(total_revenue, 2),
            'transaction_count': len(recent_records),
            'average_transaction': round(avg_transaction, 2),
            'currency_breakdown': currency_breakdown,
            'daily_average': round(total_revenue / period_days, 2)
        }

# Usage example with sample data
revenue_data = [
    {'amount': 100, 'currency': 'USD', 'date': datetime.now() - timedelta(days=1)},
    {'amount': 85, 'currency': 'EUR', 'date': datetime.now() - timedelta(days=2)},
    {'amount': 12000, 'currency': 'JPY', 'date': datetime.now() - timedelta(days=3)},
    {'amount': 0.002, 'currency': 'BTC', 'date': datetime.now() - timedelta(days=4)},
]

analytics = RevenueAnalytics(base_currency='USD')
metrics = analytics.calculate_revenue_metrics(revenue_data, period_days=7)
```

These examples demonstrate the versatility and power of the Django-CFG Currency Module across various industries and use cases. The module's robust architecture with multi-threading, retry logic, and comprehensive currency support makes it suitable for production applications handling millions of conversions daily. 💱
